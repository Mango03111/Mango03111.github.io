<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>华为昇腾HCCL算法注册与执行机制概述</title>
      <link href="/posts/58974538.html"/>
      <url>/posts/58974538.html</url>
      
        <content type="html"><![CDATA[<p>HCCL（Huawei Collective Communication Library）是华为为昇腾（Ascend）AI 处理器提供的集合通信库，用于分布式深度学习训练中多卡、多机之间的高速数据通信，它实现了 AllReduce、AllGather、Broadcast 等常见集合通信算子，并针对昇腾硬件和高速互联进行了深度优化，作用类似于 NVIDIA GPU 生态中的 NCCL，常用于 MindSpore 及 Ascend 生态下的大规模模型训练。</p><h2 id="一、整体架构"><a href="#一、整体架构" class="headerlink" title="一、整体架构"></a>一、整体架构</h2><h3 id="1-核心组件"><a href="#1-核心组件" class="headerlink" title="1. 核心组件"></a>1. 核心组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/domain/collective_communication/algorithm/</span><br><span class="line">├── pub_inc/</span><br><span class="line">│   └── coll_executor_base.h            # 执行器基类定义</span><br><span class="line">├── impl/</span><br><span class="line">│   ├── operator/</span><br><span class="line">│   │   └── custom_all_reduce_operator.cc   # 算子实现</span><br><span class="line">│   └── coll_executor/</span><br><span class="line">│       ├── registry/</span><br><span class="line">│       │   ├── coll_alg_exec_registry.h    # 注册表定义</span><br><span class="line">│       │   └── coll_alg_exec_registry.cc   # 注册表实现</span><br><span class="line">│       └── coll_all_reduce/</span><br><span class="line">│           └── coll_custom_*_executor.cc    # 具体执行器实现</span><br></pre></td></tr></table></figure><h3 id="2-类层次结构"><a href="#2-类层次结构" class="headerlink" title="2. 类层次结构"></a>2. 类层次结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CollExecutorBase</span> &#123;              <span class="comment">// 基类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HcclResult <span class="title">Orchestrate</span><span class="params">(...)</span></span>;   <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HcclResult <span class="title">CalcResRequest</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollCommExecutor</span> : <span class="keyword">public</span> CollExecutorBase &#123;  <span class="comment">// 通用实现</span></span><br><span class="line">    <span class="comment">// 公共功能实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollCustomSmallAllReduceMeshExecutor</span> : <span class="keyword">public</span> CollCommExecutor &#123;  <span class="comment">// 具体算法</span></span><br><span class="line">    <span class="comment">// 具体算法实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、注册机制"><a href="#二、注册机制" class="headerlink" title="二、注册机制"></a>二、注册机制</h2><h3 id="1-注册宏定义"><a href="#1-注册宏定义" class="headerlink" title="1. 注册宏定义"></a>1. 注册宏定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coll_alg_exec_registry.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_EXEC(tag, name, collExecBase) \</span></span><br><span class="line"><span class="meta">    static CollExecCreator collExecCreator = \</span></span><br><span class="line"><span class="meta">        [](const HcclDispatcher dispatcher, std::unique_ptr<span class="string">&lt;TopoMatcher&gt;</span> &amp;topoMatcher) \</span></span><br><span class="line"><span class="meta">            -&gt; CollExecutorBase * &#123; \</span></span><br><span class="line"><span class="meta">                return new collExecBase(dispatcher, topoMatcher); \</span></span><br><span class="line"><span class="meta">            &#125;; \</span></span><br><span class="line"><span class="meta">    static HcclResult ret = \</span></span><br><span class="line"><span class="meta">        CollAlgExecRegistry::Instance().Register(tag, collExecCreator)</span></span><br></pre></td></tr></table></figure><h3 id="2-注册表实现"><a href="#2-注册表实现" class="headerlink" title="2. 注册表实现"></a>2. 注册表实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CollAlgExecRegistry</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, CollExecCreator&gt; execCreators_;  <span class="comment">// 存储表</span></span><br><span class="line">    <span class="type">static</span> CollAlgExecRegistry globalExecRegistry;         <span class="comment">// 全局单例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CollAlgExecRegistry&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">HcclResult <span class="title">Register</span><span class="params">(<span class="type">const</span> std::string&amp; tag, <span class="type">const</span> CollExecCreator&amp; creator)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;CollExecutorBase&gt; <span class="title">GetAlgExec</span><span class="params">(<span class="type">const</span> std::string&amp; tag, ...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><h3 id="1-编译期机制"><a href="#1-编译期机制" class="headerlink" title="1. 编译期机制"></a>1. 编译期机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">源文件编译过程：</span><br><span class="line">custom_executor.cc</span><br><span class="line">    -&gt; custom_executor.o</span><br><span class="line">       ├── .text段：执行器实现代码</span><br><span class="line">       ├── .init段：注册初始化代码</span><br><span class="line">       └── .data段：静态对象数据</span><br></pre></td></tr></table></figure><h3 id="2-内存布局"><a href="#2-内存布局" class="headerlink" title="2. 内存布局"></a>2. 内存布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最终可执行文件布局：</span><br><span class="line">.init段：</span><br><span class="line">    |- 所有REGISTER_EXEC生成的初始化代码</span><br><span class="line">.data段：</span><br><span class="line">    |- CollAlgExecRegistry单例</span><br><span class="line">    |- 其他静态数据</span><br><span class="line">.text段：</span><br><span class="line">    |- 所有executor实现代码</span><br></pre></td></tr></table></figure><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 程序启动前：静态初始化</span></span><br><span class="line"><span class="type">static</span> CollExecCreator creator = [...];     <span class="comment">// 创建函数对象</span></span><br><span class="line"><span class="type">static</span> HcclResult ret = Registry::<span class="built_in">Register</span>(); <span class="comment">// 注册到表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 运行时选择算法</span></span><br><span class="line"><span class="function">HcclResult <span class="title">CustomAllReduceOperator::SelectAlg</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataSize &lt;= SMALL_COUNT) &#123;</span><br><span class="line">        algName = <span class="string">&quot;CustomSmallAllReduceMeshExecutor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建执行器实例</span></span><br><span class="line"><span class="keyword">auto</span> executor = CollAlgExecRegistry::<span class="built_in">Instance</span>().<span class="built_in">GetAlgExec</span>(algName, ...);</span><br></pre></td></tr></table></figure><h2 id="四、关键特性"><a href="#四、关键特性" class="headerlink" title="四、关键特性"></a>四、关键特性</h2><h3 id="1-静态初始化特性"><a href="#1-静态初始化特性" class="headerlink" title="1. 静态初始化特性"></a>1. 静态初始化特性</h3><ul><li>利用C++静态对象构造顺序</li><li>程序启动前完成注册</li><li>零运行时注册开销</li></ul><h3 id="2-符号可见性控制"><a href="#2-符号可见性控制" class="headerlink" title="2. 符号可见性控制"></a>2. 符号可见性控制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;  <span class="comment">// 匿名命名空间</span></span><br><span class="line">    <span class="type">static</span> CollExecCreator creator = [...];  <span class="comment">// 对外部不可见</span></span><br><span class="line">    <span class="type">static</span> HcclResult ret = [...];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-运行时灵活性"><a href="#3-运行时灵活性" class="headerlink" title="3. 运行时灵活性"></a>3. 运行时灵活性</h3><ul><li>通过字符串标识符动态选择算法</li><li>支持条件选择不同实现</li><li>易于扩展新算法</li></ul><h2 id="五、优势对比"><a href="#五、优势对比" class="headerlink" title="五、优势对比"></a>五、优势对比</h2><h3 id="1-对比传统静态链接"><a href="#1-对比传统静态链接" class="headerlink" title="1. 对比传统静态链接"></a>1. 对比传统静态链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">静态链接库：</span><br><span class="line">- 需要导出符号</span><br><span class="line">- 编译时确定</span><br><span class="line">- 按需链接.o文件</span><br><span class="line"></span><br><span class="line">HCCL注册机制：</span><br><span class="line">- 符号可完全隐藏</span><br><span class="line">- 运行时动态选择</span><br><span class="line">- 注册表统一管理</span><br></pre></td></tr></table></figure><h3 id="2-设计优势"><a href="#2-设计优势" class="headerlink" title="2. 设计优势"></a>2. 设计优势</h3><ol><li><p>更好的封装性</p><ul><li>实现细节完全隐藏</li><li>不需要导出符号</li></ul></li><li><p>更灵活的扩展性</p><ul><li>新增算法无需修改现有代码</li><li>不需要修改编译系统</li></ul></li><li><p>更好的运行时特性</p><ul><li>支持动态算法选择</li><li>统一的管理机制</li></ul></li></ol><h2 id="六、使用示例"><a href="#六、使用示例" class="headerlink" title="六、使用示例"></a>六、使用示例</h2><h3 id="1-实现新执行器"><a href="#1-实现新执行器" class="headerlink" title="1. 实现新执行器"></a>1. 实现新执行器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom_executor.cc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomExecutor</span> : <span class="keyword">public</span> CollCommExecutor &#123;</span><br><span class="line">    <span class="function">HcclResult <span class="title">Orchestrate</span><span class="params">(...)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现算法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册到框架</span></span><br><span class="line"><span class="built_in">REGISTER_EXEC</span>(<span class="string">&quot;CustomExecutor&quot;</span>, Custom, CustomExecutor);</span><br></pre></td></tr></table></figure><h3 id="2-在算子中使用"><a href="#2-在算子中使用" class="headerlink" title="2. 在算子中使用"></a>2. 在算子中使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HcclResult <span class="title">CustomOperator::SelectAlg</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (meetCondition) &#123;</span><br><span class="line">        algName = <span class="string">&quot;CustomExecutor&quot;</span>;  <span class="comment">// 选择执行器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HCCL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个机制结合了C++的静态初始化特性和运行时的灵活性，提供了一个优雅的算法注册和管理方案。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】混合整数规划（MIP, mixed integer programming）</title>
      <link href="/posts/82fbdb.html"/>
      <url>/posts/82fbdb.html</url>
      
        <content type="html"><![CDATA[<p><strong>标签</strong>: #数学优化 #线性规划 #高等难度 #组合优化 #决策优化</p><p><strong>#核心思想:</strong> 在满足线性约束条件下，优化包含连续变量和整数变量的线性目标函数，解决复杂的组合优化问题。</p><p><strong>#算法原理:</strong><br>MIP是线性规划(LP)的扩展，其中部分变量被限制为整数值。通过分支定界法、割平面法等方法，系统地在可行解空间中搜索最优解，结合线性松弛和整数约束处理来找到满足所有约束的最佳整数解。</p><p><strong>#复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>: NP难问题，最坏情况下指数级复杂度</li><li><strong>空间复杂度</strong>: O(2ⁿ) 在最坏情况下，其中n为整数变量个数</li></ul><p><strong>#代码实现:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ilcplex/ilocplex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ILOSTLBEGIN</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveMIP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IloEnv env;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">IloModel <span class="title">model</span><span class="params">(env)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义变量：连续变量x和整数变量y</span></span><br><span class="line">        <span class="function">IloNumVar <span class="title">x</span><span class="params">(env, <span class="number">0.0</span>, <span class="number">40.0</span>, ILOFLOAT, <span class="string">&quot;x&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">IloIntVar <span class="title">y</span><span class="params">(env, <span class="number">0</span>, <span class="number">100</span>, <span class="string">&quot;y&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加约束</span></span><br><span class="line">        model.<span class="built_in">add</span>(-x + <span class="number">2</span>*y &lt;= <span class="number">7</span>);</span><br><span class="line">        model.<span class="built_in">add</span>(<span class="number">2</span>*x + y &lt;= <span class="number">14</span>);</span><br><span class="line">        model.<span class="built_in">add</span>(<span class="number">2</span>*x - y &lt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置目标函数：最大化 x + y</span></span><br><span class="line">        model.<span class="built_in">add</span>(<span class="built_in">IloMaximize</span>(env, x + y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解</span></span><br><span class="line">        <span class="function">IloCplex <span class="title">cplex</span><span class="params">(model)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (cplex.<span class="built_in">solve</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;最优值: &quot;</span> &lt;&lt; cplex.<span class="built_in">getObjValue</span>() &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; cplex.<span class="built_in">getValue</span>(x) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; cplex.<span class="built_in">getValue</span>(y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (IloException&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Concert exception: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    env.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#执行流程图:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始 → 问题建模 → 线性松弛求解 → 选择分支变量 → 分支创建子问题</span><br><span class="line">    ↓                              ↑</span><br><span class="line">整数解找到 ← 检查整数性 ← 求解子问题 ← 剪枝不可行解</span><br><span class="line">    ↓</span><br><span class="line">输出最优解 → 结束</span><br></pre></td></tr></table></figure><p><strong>#适用场景:</strong></p><ul><li>生产调度和排程优化</li><li>资源分配和投资组合优化</li><li>设施选址和路径规划</li><li>机器学习中的特征选择</li></ul><p><strong>#优缺点:</strong></p><ul><li>✅ 优点：能够精确建模复杂现实问题，提供数学最优性保证</li><li>❌ 缺点：计算复杂度高，大规模问题求解时间长，对建模技巧要求高</li></ul><p><strong>#变种与改进:</strong></p><ul><li>MILP（混合整数线性规划）</li><li>MIQP（混合整数二次规划）</li><li>MINLP（混合整数非线性规划）</li><li>启发式MIP：如遗传算法、模拟退火与MIP结合</li><li>并行MIP：多线程分支定界</li></ul><p><strong>#注意事项:</strong></p><ul><li>问题规模较大时需要设置求解时间限制</li><li>选择合适的求解器参数和策略很重要</li><li>模型 formulation 对求解效率影响很大</li><li>需要注意数值稳定性和精度问题</li></ul><p><strong>#参考资料:</strong><br><a href="https://www.ibm.com/docs/en/icos/20.1.0">CPLEX优化教程 - IBM</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】广度优先搜索算法（BFS, breadth-first search）</title>
      <link href="/posts/f9717167.html"/>
      <url>/posts/f9717167.html</url>
      
        <content type="html"><![CDATA[<p><strong>标签</strong>: #图算法 #搜索算法 #中等难度 #路径查找 #连通性分析</p><p><strong>#核心思想:</strong> 从起始节点开始，逐层向外扩展探索所有可达节点，确保先访问距离起点更近的节点。</p><p><strong>#算法原理:</strong><br>BFS通过队列实现层次遍历，首先将起始节点入队并标记已访问，然后不断从队列中取出节点，访问其所有未访问的相邻节点并入队，重复此过程直到队列为空。</p><p><strong>#复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>: O(V + E)，其中V为顶点数，E为边数</li><li><strong>空间复杂度</strong>: O(V)，最坏情况下需要存储所有节点</li></ul><p><strong>#代码实现:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> startNode, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(startNode);</span><br><span class="line">    visited[startNode] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> currentNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;访问节点: &quot;</span> &lt;&lt; currentNode &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有邻居节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[currentNode]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#执行流程图:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始 → 起始节点入队 → 队列非空? → 是 → 出队并访问 → 所有未访问邻居入队</span><br><span class="line">                              ↓</span><br><span class="line">                              否 → 结束</span><br></pre></td></tr></table></figure><p><strong>#适用场景:</strong></p><ul><li>无权图的最短路径查找</li><li>连通分量检测</li><li>层级遍历树或图结构</li><li>迷宫求解问题</li><li>社交网络中的好友推荐</li></ul><p><strong>#优缺点:</strong></p><ul><li>✅ 优点：能找到最短路径（在无权图中），实现简单</li><li>❌ 缺点：空间复杂度较高，不适合深度很大的图</li></ul><p><strong>#变种与改进:</strong></p><ul><li>双向BFS：从起点和终点同时开始搜索</li><li>启发式BFS：结合估价函数优化搜索方向</li><li>多源BFS：从多个起点同时开始搜索</li></ul><p><strong>#注意事项:</strong></p><ul><li>必须标记已访问节点，避免重复访问和死循环</li><li>对于大规模图，需要注意队列的内存使用</li><li>在加权图中BFS不能保证找到最短路径</li></ul><p><strong>#参考资料:</strong></p><p><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">BFS - GeeksforGeeks</a></p><p><a href="https://www.bilibili.com/video/BV1uCH1eoEYP/?spm_id_from=333.337.search-card.all.click">BFS - Bilibili </a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Claude Code 学习笔记</title>
      <link href="/posts/57c84b4f.html"/>
      <url>/posts/57c84b4f.html</url>
      
        <content type="html"><![CDATA[<p><strong>Claude Code</strong> 是人工智能助手Claude具备的代码理解、生成和优化能力的统称，它基于大型语言模型训练而成，能够处理多种编程语言（如Python、C++、Java等）的编程任务。具体而言，Claude Code能够分析用户需求并生成相应的代码片段，调试和解释现有代码的逻辑错误，优化算法实现以提高性能，在不同编程语言之间进行转换，以及生成技术文档和测试用例。它深度理解编程范式、数据结构和算法，并能结合具体应用场景（如网络优化、数学建模、系统设计等）提供专业级编码解决方案。Claude Code的特点在于能够上下文关联地理解复杂需求，提供符合工程最佳实践的代码，同时给出清晰的技术解释，相当于一个具备全栈开发能力的AI编程助手。</p><h2 id="一、常用指令行"><a href="#一、常用指令行" class="headerlink" title="一、常用指令行"></a>一、常用指令行</h2><ol><li><code>/init</code> - 初始化阅读工程，输出到md文件</li><li>两次按<code>shift+tab</code> 进入plan mode（做计划）</li><li><code>think hard/ harder/ ultrathink</code> -代表思考力度（越右消耗token越多）</li><li><code>creat a task to xxxx</code> - 创建todo list，分步骤执行操作</li><li><code>add a task to xxx</code> - 添加 task</li><li><code>clear</code> - 清除</li><li><code>compact</code> - 主动压缩context</li></ol><h2 id="二、Context-Manage"><a href="#二、Context-Manage" class="headerlink" title="二、Context Manage"></a>二、Context Manage</h2><h3 id="1-局部上下文管理"><a href="#1-局部上下文管理" class="headerlink" title="1.局部上下文管理"></a>1.局部上下文管理</h3><p>（1）插入内容（框选、直接复制进来）</p><p>（2）插入文件（@+文件名、@&#x2F;+目录名）</p><p>（3）图片（Ctrl+v）</p><h3 id="2-整体上下文管理"><a href="#2-整体上下文管理" class="headerlink" title="2.整体上下文管理"></a>2.整体上下文管理</h3><p>（1）恢复上次对话（<code>claude -c</code>，在进入cc之前）</p><p>（2）选择历史会话（<code>claude -r</code>，同上；<code>/resume</code>，在进入cc之后）</p><h3 id="3-记忆管理"><a href="#3-记忆管理" class="headerlink" title="3.记忆管理"></a>3.记忆管理</h3><p>（1）添加记忆&#x2F;规则（# + 内容）&lt;存储到文件中&gt;</p><h2 id="三、工具与MCP"><a href="#三、工具与MCP" class="headerlink" title="三、工具与MCP"></a>三、工具与MCP</h2><h3 id="1-内置工具"><a href="#1-内置工具" class="headerlink" title="1.内置工具"></a>1.内置工具</h3><p>（1）bash超时问题：通过环境变量调整变大 <code>bash</code></p><p>（2）可以编辑jupyter notebook</p><p>（3）可以贴链接url（可以直接抓取网页内容）<code>webFetch</code></p><h3 id="2-自定义斜杠命令"><a href="#2-自定义斜杠命令" class="headerlink" title="2.自定义斜杠命令"></a>2.自定义斜杠命令</h3><p>（1）把经常打的那句话变成命令,以下是操作方法（arguments可有可无）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建个人命令</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.claude/commands</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;xxxxxxxxxxxxx:<span class="variable">$ARGUMENTS</span>&quot;</span> &gt; ~/.claude/commands/xxx.md</span><br><span class="line"><span class="comment">#md的文件名就是自定义命令名</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xxx [arguments]</span><br></pre></td></tr></table></figure><p>（2）可以调用MCP服务里面的提示词</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mcp__mcp名字__斜杠命令名 [arguments]</span><br></pre></td></tr></table></figure><h3 id="3-Model-Context-Protocol"><a href="#3-Model-Context-Protocol" class="headerlink" title="3. Model Context Protocol"></a>3. Model Context Protocol</h3><p>在Claude执行之前进行下述操作：</p><p><strong>（1）添加本地 stdio 服务器</strong></p><p>Stdio 服务器作为本地进程在您的机器上运行。它们非常适合需要直接系统访问或自定义脚本的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">claude mcp add &lt;name&gt; &lt;<span class="built_in">command</span>&gt; [args...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例：添加 Airtable 服务器</span></span><br><span class="line">claude mcp add airtable --<span class="built_in">env</span> AIRTABLE_API_KEY=YOUR_KEY \</span><br><span class="line">  -- npx -y airtable-mcp-server</span><br></pre></td></tr></table></figure><p><strong>（2）添加远程 SSE 服务器</strong></p><p>SSE（服务器发送事件）服务器提供实时流连接。许多云服务使用此功能进行实时更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">claude mcp add --transport sse &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例：连接到 Linear</span></span><br><span class="line">claude mcp add --transport sse linear https://mcp.linear.app/sse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带身份验证标头的示例</span></span><br><span class="line">claude mcp add --transport sse private-api https://api.company.com/mcp \</span><br><span class="line">  --header <span class="string">&quot;X-API-Key: your-key-here&quot;</span></span><br></pre></td></tr></table></figure><p><strong>（3）添加远程 HTTP 服务器</strong></p><p>HTTP 服务器使用标准的请求&#x2F;响应模式。大多数 REST API 和 Web 服务使用此传输方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">claude mcp add --transport http &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例：连接到 Notion</span></span><br><span class="line">claude mcp add --transport http notion https://mcp.notion.com/mcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带 Bearer 令牌的示例</span></span><br><span class="line">claude mcp add --transport http secure-api https://api.example.com/mcp \</span><br><span class="line">  --header <span class="string">&quot;Authorization: Bearer your-token&quot;</span></span><br></pre></td></tr></table></figure><p><strong>（4）管理MCP</strong></p><p>配置完成后，使用以下命令管理的 MCP 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有配置的服务器</span></span><br><span class="line">claude mcp list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取特定服务器的详细信息</span></span><br><span class="line">claude mcp get github</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除服务器</span></span><br><span class="line">claude mcp remove github</span><br><span class="line"></span><br><span class="line"><span class="comment"># （在 Claude Code 中）检查服务器状态</span></span><br><span class="line">/mcp</span><br></pre></td></tr></table></figure><p><strong>（5） <a href="https://docs.anthropic.com/zh-CN/docs/claude-code/mcp#mcp-%E5%AE%89%E8%A3%85%E8%8C%83%E5%9B%B4">MCP 安装范围</a></strong></p><p>MCP 服务器可以在三个不同的范围级别配置，每个级别都有不同的目的来管理服务器可访问性和共享。了解这些范围有助于确定为特定需求配置服务器的最佳方式。</p><ul><li><strong>本地范围</strong>：个人服务器、实验性配置或特定于一个项目的敏感凭据</li><li><strong>项目范围</strong>：团队共享服务器、项目特定工具或协作所需的服务</li><li><strong>用户范围</strong>：多个项目需要的个人实用程序、开发工具或经常使用的服务</li></ul><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><h3 id="1-Work-Flow"><a href="#1-Work-Flow" class="headerlink" title="1. Work Flow"></a>1. Work Flow</h3><p>（1）<code>CLAUDE.md</code> <code>/init</code></p><p>（2）按<code>ESC</code>中断操作，而不损失上下文；按两下<code> ESC</code>清除当前操作输出内容</p><p>（3）<code>Shift+Tab</code>进入自动接受模式</p><p>（4）可以让它把<strong>问题列表</strong>存储到各个<code>.md</code>文件中，以便项目迁移和上下文存储</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 学习笔记</title>
      <link href="/posts/d87f7e0c.html"/>
      <url>/posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown</strong>是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 <code>HTML</code>、<code>PDF</code> 以及本身的<code> .md</code> 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如<a href="https://github.com/" title="你好呀">Github</a><strong>、</strong><code>Wikipedia</code><strong>、</strong><code>简书</code>**等。</p><h2 id="一、标题语法（-）"><a href="#一、标题语法（-）" class="headerlink" title="一、标题语法（#）"></a>一、标题语法（<code>#</code>）</h2><p>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。</p><p>不同的 Markdown 应用程序处理 # 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 # 和标题之间进行分隔。</p><h2 id="二、段落语法"><a href="#二、段落语法" class="headerlink" title="二、段落语法"></a>二、段落语法</h2><p><strong>不要用空格（spaces）或制表符（ tabs）缩进段落。</strong></p><h2 id="三、换行语法（）"><a href="#三、换行语法（）" class="headerlink" title="三、换行语法（&lt;br&gt;）"></a>三、换行语法（<code>&lt;br&gt;</code>）</h2><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)。</p><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 <code>结尾空格（trailing whitespace)</code> 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code> 标签。</p><h2 id="四、强调语法"><a href="#四、强调语法" class="headerlink" title="四、强调语法(*)"></a>四、强调语法(<code>*</code>)</h2><h3 id="1、粗体（-）"><a href="#1、粗体（-）" class="headerlink" title="1、粗体（**）"></a>1、粗体（**）</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号**（asterisks）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p><p><strong>加粗文字</strong></p><h3 id="2、斜体（-）"><a href="#2、斜体（-）" class="headerlink" title="2、斜体（*）"></a>2、斜体（*）</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><p><em>斜体文字</em></p><h3 id="3、粗体-斜体（-）"><a href="#3、粗体-斜体（-）" class="headerlink" title="3、粗体&amp;斜体（***）"></a>3、粗体&amp;斜体（***）</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><h2 id="五、引用语法"><a href="#五、引用语法" class="headerlink" title="五、引用语法(&gt;)"></a>五、引用语法(<code>&gt;</code>)</h2><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p><h4 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h4><p>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p><h4 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h4><p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p><h2 id="六、列表语法-1"><a href="#六、列表语法-1" class="headerlink" title="六、列表语法(1. - * +)"></a>六、列表语法(<code>1.</code> <code>- * +</code>)</h2><h3 id="1、有序列表"><a href="#1、有序列表" class="headerlink" title="1、有序列表"></a>1、有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><ol><li>hhh</li><li>hhh</li><li>hhh</li></ol><h3 id="2、无序列表"><a href="#2、无序列表" class="headerlink" title="2、无序列表"></a>2、无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><h3 id="3、在列表中嵌套其他元素"><a href="#3、在列表中嵌套其他元素" class="headerlink" title="3、在列表中嵌套其他元素"></a>3、在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进<strong>四个空格</strong>或<strong>一个制表符（tab）</strong>。</p><h2 id="七、代码语法"><a href="#七、代码语法" class="headerlink" title="七、代码语法(&#96;&#96;&#96;)"></a>七、代码语法(&#96;&#96;&#96;)</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (&#96;&#96;&#96;) 中。</p><table><thead><tr><th>Markdown语法</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>At the command prompt, type </code>nano<code>.</code></td><td><code>At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</code></td><td>At the command prompt, type <code>nano</code>.</td></tr></tbody></table><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(&#96;&#96;&#96;&#96;)中。</p><table><thead><tr><th>Markdown语法</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>Use `code` in your Markdown file.</code></td><td><code>&lt;code&gt;Use </code>code<code> in your Markdown file.&lt;/code&gt;</code></td><td><code>Use </code>code<code> in your Markdown file.</code></td></tr></tbody></table><h3 id="代码块"><a href="#代码块" class="headerlink" title="#代码块"></a><a href="https://markdown.com.cn/basic-syntax/code.html#%E4%BB%A3%E7%A0%81%E5%9D%97">#</a>代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;html&gt;</span><br><span class="line">  &amp;lt;head&gt;</span><br><span class="line">  &amp;lt;/head&gt;</span><br><span class="line">&amp;lt;/html&gt;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;html&gt;</span><br><span class="line">  &amp;lt;head&gt;</span><br><span class="line">  &amp;lt;/head&gt;</span><br><span class="line">&amp;lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 要创建不用缩进的代码块，请使用 <a href="https://markdown.com.cn/extended-syntax/fenced-code-blocks.html">围栏式代码块（fenced code blocks）</a>.</p><h2 id="八、分割线语法"><a href="#八、分割线语法" class="headerlink" title="八、分割线语法(*** --- ___)"></a>八、分割线语法(<code>***</code> <code>---</code> <code>___</code>)</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p><p>示例：</p><hr><hr><hr><h2 id="九、链接语法"><a href="#九、链接语法" class="headerlink" title="九、链接语法([](&quot;&quot;))"></a>九、链接语法(<code>[](&quot;&quot;)</code>)</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><h3 id="1、给链接加定义"><a href="#1、给链接加定义" class="headerlink" title="1、给链接加定义"></a>1、给链接加定义</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。lg：<a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a></p><h3 id="2、网址和Email地址"><a href="#2、网址和Email地址" class="headerlink" title="2、网址和Email地址"></a>2、网址和Email地址</h3><p>使用尖括号（&lt;&gt;）可以很方便地把URL或者email地址变成可点击的链接。</p><p><a href="https://markdown.com.cn/">https://markdown.com.cn</a></p><h3 id="3、带格式化的链接"><a href="#3、带格式化的链接" class="headerlink" title="3、带格式化的链接"></a>3、带格式化的链接</h3><p><a href="https://markdown.com.cn/basic-syntax/links.html#emphasis">强调</a> 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I love supporting the **[EFF](https://eff.org)**.</span><br><span class="line">This is the *[Markdown Guide](https://www.markdownguide.org)*.</span><br><span class="line">See the section on [`code`](#code).</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p>I love supporting the <strong><a href="https://eff.org/">EFF (opens new window)</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide (opens new window)</a></em>.<br>See the section on <a href="https://markdown.com.cn/basic-syntax/links.html#code"><code>code</code></a>.</p><h3 id="4、引用类型链接"><a href="#4、引用类型链接" class="headerlink" title="4、引用类型链接"></a>4、引用类型链接</h3><h4 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h4><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><ul><li><code>[hobbit-hole][1]</code></li><li><code>[hobbit-hole] [1]</code></li></ul><h4 id="链接的第二部分格式"><a href="#链接的第二部分格式" class="headerlink" title="链接的第二部分格式"></a>链接的第二部分格式</h4><p>引用类型链接的第二部分使用以下属性设置格式：</p><ol><li>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如<code>[label]:</code>）。</li><li>链接的URL，可以选择将其括在尖括号中。</li><li>链接的可选标题，可以将其括在双引号，单引号或括号中。</li></ol><p>以下示例格式对于链接的第二部分效果相同：</p><ul><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</code></li></ul><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。</p><h2 id="十、图片语法"><a href="#十、图片语法" class="headerlink" title="十、图片语法(![]( &quot;&quot;))"></a>十、图片语法(<code>![]( &quot;&quot;)</code>)</h2><p>要添加图像，请使用感叹号 (<code>!</code>), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><h2 id="十一、转义字符语法（-）"><a href="#十一、转义字符语法（-）" class="headerlink" title="十一、转义字符语法（\）"></a>十一、转义字符语法（<code>\</code>）</h2><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><h2 id="十二、内嵌HTML标签"><a href="#十二、内嵌HTML标签" class="headerlink" title="十二、内嵌HTML标签"></a>十二、内嵌HTML标签</h2><p>没啥特殊作用，可以不用（知道markdown语法和HTML可以级联就好）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于此网站</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="欢迎来到Mango的Blog！！！"><a href="#欢迎来到Mango的Blog！！！" class="headerlink" title="欢迎来到Mango的Blog！！！"></a>欢迎来到Mango的Blog！！！</h3><p>在这里，我将会分享个人在学习、工作以及爱好等方面的文章，希望能和大家交流互助~</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>学习笔记</li><li>计算机网络</li><li>算法</li><li>Mango的爱好杂谈</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>markdown</li><li>AI</li><li>Algorithm</li></ul>]]></content>
      
    </entry>
    
    
  
</search>
