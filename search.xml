<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>latex安装教程</title>
      <link href="/posts/6317b69f.html"/>
      <url>/posts/6317b69f.html</url>
      
        <content type="html"><![CDATA[<p>预留位</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>wallpaper壁纸解包软件推荐</title>
      <link href="/posts/f09cdbbd.html"/>
      <url>/posts/f09cdbbd.html</url>
      
        <content type="html"><![CDATA[<p><strong>RePKG</strong> 是一款开源的资源解包工具，专门用于提取 <strong>Wallpaper Engine</strong> 动态壁纸包（<code>.pkg</code> 文件）中的资源内容。通过该工具，可以将壁纸中的图片、纹理、音频及项目文件完整提取出来。此外，RePKG 还支持将 Wallpaper Engine 使用的 <strong>TEX 纹理格式</strong> 转换为常见图片格式（如 PNG&#x2F;JPG），方便查看、编辑或二次创作。</p><p>该工具为命令行程序，体积小、使用简单，适合壁纸爱好者、内容创作者及开发者使用。</p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/578573147">https://zhuanlan.zhihu.com/p/578573147</a></p><hr><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><strong>官方 GitHub 下载地址（推荐下载最新版）：</strong></p><p>👉 <a href="https://github.com/notscuffed/repkg/releases">https://github.com/notscuffed/repkg/releases</a></p><p>下载后解压即可使用，无需安装。</p><p><strong>如果没有魔法，也可以通过以下链接下载（网盘下载）：</strong></p><p>👉<a href="https://wwc.lanzouw.com/iZVay064qleh">https://wwc.lanzouw.com/iZVay064qleh</a></p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>下载并解压 RePKG 工具压缩包。</p></li><li><p>将需要解包的 <code>.pkg</code> 文件准备好（通常来自 Wallpaper Engine 的 Workshop 目录，可在wallpaper中<code>右键-在资源管理器中打开</code>）。</p><p><img src="/posts/f09cdbbd/%E6%88%AA%E5%9B%BE20260217002809.png" alt="截图20260217002809"></p></li><li><p>建议新建一个单独文件夹，将：</p><ul><li><code>repkg.exe</code></li><li>需要解包的 <code>.pkg</code> 文件<br>放在同一个目录中，便于操作。</li></ul></li></ol><hr><h2 id="操作方法一：PowerShell-自动化脚本（需下载网盘压缩包）"><a href="#操作方法一：PowerShell-自动化脚本（需下载网盘压缩包）" class="headerlink" title="操作方法一：PowerShell 自动化脚本（需下载网盘压缩包）"></a>操作方法一：PowerShell 自动化脚本（需下载网盘压缩包）</h2><p>直接右键 - 使用powershell运行：</p><p><img src="/posts/f09cdbbd/%E6%88%AA%E5%9B%BE20260217003033.png" alt="截图20260217003033"></p><p>执行完成后，程序会在当前目录下生成一个output文件夹，里面就是解包后的资源文件。</p><h2 id="操作方法二：PowerShell-命令行解包（通用）"><a href="#操作方法二：PowerShell-命令行解包（通用）" class="headerlink" title="操作方法二：PowerShell 命令行解包（通用）"></a>操作方法二：PowerShell 命令行解包（通用）</h2><h3 id="第一步：打开-PowerShell"><a href="#第一步：打开-PowerShell" class="headerlink" title="第一步：打开 PowerShell"></a>第一步：打开 PowerShell</h3><p>在包含 <code>repkg.exe</code> 和 <code>.pkg</code> 文件的文件夹中：</p><ul><li>在空白处右键</li><li>选择 <strong>“在此处打开 PowerShell”</strong></li></ul><hr><h3 id="第二步：执行解包命令"><a href="#第二步：执行解包命令" class="headerlink" title="第二步：执行解包命令"></a>第二步：执行解包命令</h3><p>在 PowerShell 中输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repkg extract E:\Games\steamapps\workshop\content\<span class="number">123</span>\scene.pkg </span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>repkg</code> —— 工具主程序</li><li><code>extract</code> —— 提取命令</li><li><code>my_wallpaper.pkg</code> —— 你要解包的文件名(注意前面的路径要修改成你自己的路径)</li></ul><p>执行完成后，程序会在当前目录下生成一个output文件夹，里面就是解包后的资源文件。</p><hr><h2 id="进阶用法（常用参数说明）"><a href="#进阶用法（常用参数说明）" class="headerlink" title="进阶用法（常用参数说明）"></a>进阶用法（常用参数说明）</h2><p>下面是一些常见的高级使用场景示例，你可以根据需求选择对应命令。</p><hr><h3 id="1️⃣-批量查找子目录中的-PKG-并生成完整项目结构"><a href="#1️⃣-批量查找子目录中的-PKG-并生成完整项目结构" class="headerlink" title="1️⃣ 批量查找子目录中的 PKG 并生成完整项目结构"></a>1️⃣ 批量查找子目录中的 PKG 并生成完整项目结构</h3><p>递归搜索指定目录下所有子文件夹中的 <code>.pkg</code> 文件，并将它们转换为完整的 Wallpaper Engine 项目结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repkg extract -c E:\Games\steamapps\workshop\content\123</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-c</code> ：创建完整的 Wallpaper Engine 项目结构</li><li>自动扫描该目录及其子目录中的所有 PKG 文件</li></ul><p>适用于：</p><ul><li>批量整理 Workshop 下载的壁纸</li><li>将多个壁纸转换为可编辑项目</li></ul><hr><h3 id="2️⃣-批量查找-PKG，只转换-TEX-为-PNG，并统一输出到指定目录"><a href="#2️⃣-批量查找-PKG，只转换-TEX-为-PNG，并统一输出到指定目录" class="headerlink" title="2️⃣ 批量查找 PKG，只转换 TEX 为 PNG，并统一输出到指定目录"></a>2️⃣ 批量查找 PKG，只转换 TEX 为 PNG，并统一输出到指定目录</h3><p>递归查找目录中的所有 PKG 文件，仅提取 TEX 文件并转换为 PNG 格式，同时忽略原始路径结构，统一输出到 <code>./output</code> 文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repkg extract -e tex -s -o ./output E:\Games\steamapps\workshop\content\123</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-e tex</code> ：仅处理 TEX 文件</li><li><code>-s</code> ：忽略原始路径结构（扁平化输出）</li><li><code>-o ./output</code> ：指定输出目录</li></ul><p>适用于：</p><ul><li>批量提取所有壁纸的贴图</li><li>统一整理为一个图片文件夹</li></ul><hr><h3 id="3️⃣批量转换指定文件夹中的-TEX-文件"><a href="#3️⃣批量转换指定文件夹中的-TEX-文件" class="headerlink" title="3️⃣批量转换指定文件夹中的 TEX 文件"></a>3️⃣批量转换指定文件夹中的 TEX 文件</h3><p>如果你已经单独提取了 TEX 文件，只想将它们转换为图片格式，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repkg extract -t -s E:\path\to\dir\with\tex\files</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-t</code> ：转换 TEX 文件为图片</li><li><code>-s</code> ：忽略原始路径结构</li></ul><p>适用于：</p><ul><li>已有 TEX 文件，仅需转换格式</li><li>单独整理贴图资源</li></ul><hr><h3 id="常见参数汇总"><a href="#常见参数汇总" class="headerlink" title="常见参数汇总"></a>常见参数汇总</h3><table><thead><tr><th>参数</th><th align="left">作用</th></tr></thead><tbody><tr><td><code>-c</code></td><td align="left">创建完整 Wallpaper Engine 项目结构</td></tr><tr><td><code>-e</code></td><td align="left">仅提取指定扩展名文件</td></tr><tr><td><code>-t</code></td><td align="left">转换 TEX 文件为图片</td></tr><tr><td><code>-s</code></td><td align="left">忽略原始路径结构（扁平化输出）</td></tr><tr><td><code>-o</code></td><td align="left">指定输出目录</td></tr></tbody></table><p>解包完成后，你会看到以下内容：</p><ul><li>图片文件（PNG &#x2F; JPG）</li><li>纹理文件（TEX）</li><li>音频文件</li><li>配置文件（如 project.json）</li><li>其他资源文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 梦啥说啥 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>【教程】Omnetpp软件安装教程</title>
      <link href="/posts/6f93af5f.html"/>
      <url>/posts/6f93af5f.html</url>
      
        <content type="html"><![CDATA[<p>OMNeT++ 是一款基于离散事件的网络仿真平台，常用于通信网络、协议设计与性能分析。由于其 IDE 基于 Java，同时核心库需要本地编译，因此安装过程相比普通软件稍复杂。本文将详细讲解在<strong>windows</strong>环境中 <strong>JDK 安装 → OMNeT++ 构建 → 示例验证 → IDE 启动</strong> 的完整流程。</p><p><em>由于本人新购入了一台笔记本，很多软件都需要重新配置，趁此机会，我将会把安装配置的过程整理成一系列的教程，供大家学习与参考。</em></p><h2 id="安装并验证-JDK（已安装请跳过）"><a href="#安装并验证-JDK（已安装请跳过）" class="headerlink" title="安装并验证 JDK（已安装请跳过）"></a>安装并验证 JDK（已安装请跳过）</h2><p>OMNeT++ 的图形界面（IDE）是基于 Java 的，如果系统中没有正确配置 JDK，后续即使 OMNeT++ 编译成功，也<strong>无法正常启动 IDE</strong>。因此，JDK 是整个环境的基础。</p><h3 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h3><p>推荐从国内镜像进行下载，这里提供华为云的镜像：<a href="https://repo.huaweicloud.com/java/jdk/">https://repo.huaweicloud.com/java/jdk/</a></p><p>推荐使用 <strong>JDK 8 或以上版本</strong>，我安装的是JDK11。安装过程较为简单，按提示“下一步”即可。</p><p>安装完成后，需要手动配置环境变量，让系统能够在任何位置识别 Java 命令。</p><hr><h3 id="配置-JDK-环境变量"><a href="#配置-JDK-环境变量" class="headerlink" title="配置 JDK 环境变量"></a>配置 JDK 环境变量</h3><p>右键此电脑，点击<strong>属性-&gt;高级系统设置-&gt;环境变量</strong></p><p><img src="/posts/6f93af5f/1-1770127695573-4.png" alt="1"></p><p>在<strong>系统环境变量</strong>中新增：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME</span><br><span class="line">C:\Program Files\Java\jdk&lt;版本号&gt; //这里指的是你的软件安装目录，默认在C盘</span><br></pre></td></tr></table></figure><p><img src="/posts/6f93af5f/%E6%88%AA%E5%9B%BE20260202231434.png" alt="截图20260202231434"></p><p>并在 <code>Path</code> 中加入：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%JAVA_HOME%\bin</span><br></pre></td></tr></table></figure><p><img src="/posts/6f93af5f/%E6%88%AA%E5%9B%BE20260202231616.png" alt="截图20260202231616"></p><p>这一步的作用是：</p><ul><li><code>JAVA_HOME</code> 告诉系统 JDK 安装在哪</li><li><code>Path</code> 让 <code>java</code>、<code>javac</code> 这些命令可以在命令行中直接使用</li></ul><p><strong>需要注意的是：如果你的电脑之前有配过其他jdk环境，请将本此添加的环境变量写到靠上的位置</strong></p><hr><h3 id="验证-JDK-是否可用"><a href="#验证-JDK-是否可用" class="headerlink" title="验证 JDK 是否可用"></a>验证 JDK 是否可用</h3><p>打开 <strong>cmd</strong>，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure><p>如果能看到版本号输出，说明 JDK 已正确安装并生效；<br>如果提示“不是内部或外部命令”，通常是环境变量未配置成功。</p><hr><h2 id="下载并解压-OMNeT"><a href="#下载并解压-OMNeT" class="headerlink" title="下载并解压 OMNeT++"></a>下载并解压 OMNeT++</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>推荐从官网下载：</p><p><a href="https://omnetpp.org/download/old">https://omnetpp.org/download/old</a></p><p>（由于是科研用途，为了代码兼容性，ANTL实验室的同学请统一下载5.6.2的版本）</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>OMNeT++ 在 Windows 下<strong>不是传统的安装程序</strong>，而是一个需要手动编译的源码包。</p><p>下载完成后，将压缩包解压到<strong>不包含中文和空格</strong>的路径中，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E:\Software\omnetpp-5.6.2</span><br></pre></td></tr></table></figure><p>这样做可以避免后续脚本和编译工具出现路径解析错误。</p><hr><h2 id="构建-OMNeT"><a href="#构建-OMNeT" class="headerlink" title="构建 OMNeT++"></a>构建 OMNeT++</h2><h3 id="启动专用构建环境"><a href="#启动专用构建环境" class="headerlink" title="启动专用构建环境"></a>启动专用构建环境</h3><p>进入 OMNeT++ 解压目录，双击运行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mingwenv.cmd</span><br></pre></td></tr></table></figure><p>这个文件的作用是：</p><blockquote><p>打开一个<strong>已经配置好编译工具（gcc、make 等）</strong>的命令行环境。</p></blockquote><p>后续所有命令 <strong>都必须在这个窗口中执行</strong>，不要用普通 cmd。</p><p>如果出现 <strong>Windows 已保护你的电脑</strong> ，带点击<code>更多信息</code>选择<code>仍要运行</code><br>如果出现**请按任意键继续. . .**，随便按一下键盘即可。<br>出现Shell命令界面，等待其运行完成，大概几分钟，接着会出现一个新的窗口。</p><hr><h3 id="生成构建配置"><a href="#生成构建配置" class="headerlink" title="生成构建配置"></a>生成构建配置</h3><p>在打开的命令行窗口中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>这条命令主要做三件事：</p><ul><li>检查当前系统是否具备编译 OMNeT++ 的条件</li><li>检测 JDK、编译器等依赖</li><li>生成后续 <code>make</code> 所需的配置文件</li></ul><p>如果中途没有报错，说明系统环境基本没问题。</p><hr><h3 id="编译-OMNeT-核心库（make）"><a href="#编译-OMNeT-核心库（make）" class="headerlink" title="编译 OMNeT++ 核心库（make）"></a>编译 OMNeT++ 核心库（make）</h3><p>继续输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure><p>或者（推荐，多核 CPU 更快）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8</span><br></pre></td></tr></table></figure><p>这里的 <code>-j8</code> 表示使用 8 个线程并行编译，可以显著缩短时间。</p><p>💡 这个过程通常会持续 <strong>几分钟到几十分钟</strong>，期间屏幕会不断滚动输出，这是正常现象，只要最后没有 error 即可。</p><hr><h2 id="运行示例程序（判断是否安装成功的关键）"><a href="#运行示例程序（判断是否安装成功的关键）" class="headerlink" title="运行示例程序（判断是否安装成功的关键）"></a>运行示例程序（判断是否安装成功的关键）</h2><p>编译完成后，进入官方示例目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> samples/aloha</span><br></pre></td></tr></table></figure><p>然后运行示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./aloha</span><br></pre></td></tr></table></figure><p>如果出现仿真窗口，并能看到节点、事件或结果输出，说明：</p><p>✅ OMNeT++ 已成功编译<br>✅ 运行环境正常</p><p>如果这一步失败，说明前面的构建或环境变量仍有问题。</p><hr><h2 id="配置-OMNeT-环境变量（让命令随处可用）"><a href="#配置-OMNeT-环境变量（让命令随处可用）" class="headerlink" title="配置 OMNeT++ 环境变量（让命令随处可用）"></a>配置 OMNeT++ 环境变量（让命令随处可用）</h2><p>为了以后不必每次都进入安装目录，可以设置 OMNeT++ 的环境变量。</p><h3 id="新增系统变量："><a href="#新增系统变量：" class="headerlink" title="新增系统变量："></a>新增系统变量：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OMNET_HOME </span><br><span class="line">E:\omnetpp-5.6.2 //这里依旧是你的软件安装目录，按照自己的目录粘贴</span><br></pre></td></tr></table></figure><p><img src="/posts/6f93af5f/%E6%88%AA%E5%9B%BE20260202231719.png" alt="截图20260202231719"></p><h3 id="修改-Path，依次加入："><a href="#修改-Path，依次加入：" class="headerlink" title="修改 Path，依次加入："></a>修改 Path，依次加入：</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%OMNET_HOME%\bin</span><br><span class="line">%OMNET_HOME%\tools\win64\usr\bin</span><br><span class="line">%OMNET_HOME%\tools\win64\mingw64\bin</span><br><span class="line">%OMNET_HOME%\tools\win64\opt\mingw64\bin</span><br></pre></td></tr></table></figure><p><img src="/posts/6f93af5f/%E6%88%AA%E5%9B%BE20260202231657.png" alt="截图20260202231657"></p><p>设置完成后，<strong>重启系统</strong>，确保变量生效。（实测不重启不影响后续安装验证）</p><hr><h2 id="启动-OMNeT-IDE（图形界面）"><a href="#启动-OMNeT-IDE（图形界面）" class="headerlink" title="启动 OMNeT++ IDE（图形界面）"></a>启动 OMNeT++ IDE（图形界面）</h2><p>重启后，打开mingwenv.cmd，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">omnetpp</span><br></pre></td></tr></table></figure><p>如果 IDE 正常启动，说明 Java、OMNeT++ 和环境变量三者已经正确协同工作。</p><p><img src="/posts/6f93af5f/capture_20260202231028096.bmp" alt="capture_20260202231028096"></p><p><strong>建议将mingwenv.cmd（右键 - &gt; 发送到桌面快捷方式），这样每次启动就可以在桌面上直接启动了；</strong>由于omnetpp5.6.2没有配好的快捷启动图标，这里不做配置赘述，感兴趣的同学可以自行探究。</p><hr><h2 id="在-IDE-中运行仿真项目"><a href="#在-IDE-中运行仿真项目" class="headerlink" title="在 IDE 中运行仿真项目"></a>在 IDE 中运行仿真项目</h2><p>进入 IDE 后：</p><ol><li><p>选择工作空间（Workspace）</p></li><li><p>导入示例工程或自建工程</p></li><li><p>右键项目 →</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Run As → OMNeT++ Simulation</span><br></pre></td></tr></table></figure></li></ol><p>即可运行仿真模型并查看结果。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【教程】Typora 免费安装指南（仅支持版本：1.9.5）</title>
      <link href="/posts/77789012.html"/>
      <url>/posts/77789012.html</url>
      
        <content type="html"><![CDATA[<p>Typora 是一款跨平台的 Markdown 文本编辑器，其最大的特点是“<strong>所见即所得（WYSIWYG）</strong>”的编辑体验。这意味着当你在 Typora 中输入 Markdown 语法时，它会在同一界面实时渲染、显示最终效果，而不是像其他很多编辑器那样需要分别显示源码窗口和预览窗口。</p><p><strong>主要优点包括：</strong></p><ul><li><strong>实时预览</strong>：无需切换视图，即时看到排版后的效果。</li><li><strong>界面简洁</strong>：专注内容编辑，不受复杂 UI 干扰。</li><li><strong>支持丰富导出格式</strong>：如 PDF、HTML、Word 等，方便分享与发布。</li><li><strong>主题与样式多样化</strong>：可根据喜好自定义外观。</li><li><strong>跨平台支持</strong>：可用于 Windows、macOS、Linux 等系统。</li></ul><p>这种编辑模式使 Typora <strong>既适合写博客、笔记，也适合编写技术文档与代码说明</strong>。</p><hr><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在正式安装之前，你需要准备：</p><ol><li><strong>Typora 官方安装包</strong>（建议选择 1.9.5 版本，因为后续版本可能需要付费或不兼容免费激活工具）</li><li><strong>辅助工具包</strong>（包含两个可执行文件：<code>node_inject.exe</code> 和 <code>license-gen.exe</code>），用于生成激活序列号。</li></ol><p>⚠️ 注意：这些辅助工具来源于开源项目，<strong>仅限学习与技术交流使用</strong>。在使用时请保证来源合法且不要用于商业传播。</p><hr><h2 id="详细安装步骤"><a href="#详细安装步骤" class="headerlink" title="详细安装步骤"></a>详细安装步骤</h2><p>下面是逐步说明每一个操作及其作用：</p><hr><h3 id="步骤-1-—-下载必要文件"><a href="#步骤-1-—-下载必要文件" class="headerlink" title="步骤 1 — 下载必要文件"></a><strong>步骤 1 — 下载必要文件</strong></h3><p>你需要分别下载：</p><p><strong>Typora 官方安装包</strong>：可以从官网或可信任的镜像站获取安装程序，在历史版本中选择1.9.3版本（解压后会更新为1.9.5版本）。</p><p>Typora 中文官网地址：<a href="https://typoraio.cn/">Typora中文网</a></p><p><strong>激活辅助工具包</strong>：下载解压后会得到两个文件：</p><ul><li><code>node_inject.exe</code></li><li><code>license-gen.exe</code></li></ul><p>网盘分享的链接：<a href="https://pan.baidu.com/s/1dkg9FMa77zXLRcenipHAhw?pwd=s3w3">下载 Typroa_Activation_Script</a></p><p>👉 将下载的文件解压并准备好相关工具。</p><hr><h3 id="步骤-2-—-安装-Typora"><a href="#步骤-2-—-安装-Typora" class="headerlink" title="步骤 2 — 安装 Typora"></a><strong>步骤 2 — 安装 Typora</strong></h3><p>双击运行 Typora 安装程序，按照安装向导提示一步一步进行安装：</p><ul><li>选择安装路径（建议默认安装路径或者自定义路径）</li><li>点击“下一步”</li><li>等待安装完成</li></ul><p>👉 这一步只是将 Typora 安装到电脑上，并<strong>不运行它（注意在点finish之前取消勾选运行框）</strong>。</p><hr><h3 id="步骤-3-—-准备激活工具"><a href="#步骤-3-—-准备激活工具" class="headerlink" title="步骤 3 — 准备激活工具"></a><strong>步骤 3 — 准备激活工具</strong></h3><p>将下载并解压出的两个激活工具文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_inject.exe</span><br><span class="line">license-gen.exe</span><br></pre></td></tr></table></figure><p>复制到你刚才安装 Typora 的目录下。例如默认路径可能是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\Typora</span><br></pre></td></tr></table></figure><p>如果你安装到其他盘（如 D 盘），路径可能类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files\Typora</span><br></pre></td></tr></table></figure><p>👉 将程序和工具放在同一文件夹有利于后续命令执行。</p><hr><h3 id="步骤-4-—-打开管理员命令行"><a href="#步骤-4-—-打开管理员命令行" class="headerlink" title="步骤 4 — 打开管理员命令行"></a><strong>步骤 4 — 打开管理员命令行</strong></h3><p>为了运行激活工具，你需要启动 <strong>命令提示符（CMD）</strong> 并以管理员身份运行：</p><ol><li>按下 <strong>Windows</strong> 键</li><li>搜索：<code>CMD</code></li><li>右击“命令提示符”，选择“<strong>以管理员身份运行</strong>”</li></ol><p>👉 以管理员身份运行是为了保证激活工具有足够权限写入相关信息。</p><hr><h3 id="步骤-5-—-生成激活序列号"><a href="#步骤-5-—-生成激活序列号" class="headerlink" title="步骤 5 — 生成激活序列号"></a><strong>步骤 5 — 生成激活序列号</strong></h3><p>在管理员 CMD 中，输入如下命令：</p><ol><li><p>跳转到 Typora 安装目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Program Files\Typora</span><br></pre></td></tr></table></figure></li><li><p>运行第一个工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node_inject.exe</span><br></pre></td></tr></table></figure><p>等待命令行提示 “done!” 说明注入成功。</p></li><li><p>再运行生成序列号的工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">license-gen.exe</span><br></pre></td></tr></table></figure><p>等待程序显示生成的序列号。</p><p><img src="/posts/77789012/%E6%88%AA%E5%9B%BE20260202235740.png" alt="截图20260202235740"></p></li></ol><p>👉 这一步是关键：它会生成一个可以用于激活 Typora 的有效序列号。</p><hr><h3 id="步骤-6-—-激活-Typora"><a href="#步骤-6-—-激活-Typora" class="headerlink" title="步骤 6 — 激活 Typora"></a><strong>步骤 6 — 激活 Typora</strong></h3><p>现在打开 Typora：</p><ol><li>输入一个任意邮箱地址（如 <a href="mailto:test@example.com">test@example.com</a>）</li><li>将刚才生成的序列号粘贴到激活界面</li><li>点击确认完成激活</li></ol><p><img src="/posts/77789012/%E6%88%AA%E5%9B%BE20260202235630.png" alt="截图20260202235630"></p><p><img src="/posts/77789012/%E6%88%AA%E5%9B%BE20260202235722.png" alt="截图20260202235722"></p><p>如果一切配置没有问题，你应该会看到 <strong>Typora 已被成功激活</strong> 的提示。</p><hr><h3 id="步骤-7-—-异常处理提示"><a href="#步骤-7-—-异常处理提示" class="headerlink" title="步骤 7 — 异常处理提示"></a><strong>步骤 7 — 异常处理提示</strong></h3><p>激活过程若出现错误提示：</p><ul><li>可能是网络原因（工具试图联网验证）</li></ul><p>一般情况下，只需点击确认继续即可解决多数错误提示。</p><p><img src="/posts/77789012/%E6%88%AA%E5%9B%BE20260202235707.png" alt="截图20260202235707"></p><hr><h3 id="步骤-8-—-安装完成注意事项"><a href="#步骤-8-—-安装完成注意事项" class="headerlink" title="步骤 8 — 安装完成注意事项"></a><strong>步骤 8 — 安装完成注意事项</strong></h3><ul><li><strong>完成后请不要自动更新 Typora</strong>，更新可能导致激活失效。</li><li>若升级需要重新激活，可重复以上步骤。</li></ul><p>🎉 至此，你就成功安装并激活了 Typora，可以开始流畅写 Markdown 文档啦！</p><hr><h2 id="软件使用—偏好设置与建议"><a href="#软件使用—偏好设置与建议" class="headerlink" title="软件使用—偏好设置与建议"></a>软件使用—偏好设置与建议</h2><ol><li>点击 偏好设置 - &gt; 图像 -&gt; 复制图片到.&#x2F;${filename}.assets文件夹;</li><li>点击 markdown - &gt; 勾选全部“markdown拓展语法”；</li><li>启动选项 - &gt; 重新打开上次启动的目录；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【教程】Codex CLI 安装与 VS Code 插件使用教程</title>
      <link href="/posts/9975aeb1.html"/>
      <url>/posts/9975aeb1.html</url>
      
        <content type="html"><![CDATA[<p><strong>Codex</strong> 是 OpenAI 推出的新一代 <strong>AI 编程智能体（Coding Agent）</strong>，它不只是“会写代码的 ChatGPT”，而是一个<strong>可以直接参与你真实开发流程的工具</strong>。与传统在网页里对话的 ChatGPT 不同，Codex 被设计为：</p><ul><li><strong>运行在本地开发环境中</strong></li><li><strong>理解你的项目结构</strong></li><li><strong>能操作文件、执行命令、修改代码</strong></li></ul><p><strong>那Codex 和 ChatGPT 写代码有什么本质区别？</strong></p><p>很多人第一反应是：</p><blockquote><p>“我用 ChatGPT 写代码也挺好，为什么还要 Codex？”</p></blockquote><p>关键差别在于 <strong>上下文深度和执行能力</strong>。</p><table><thead><tr><th>维度</th><th>ChatGPT（网页）</th><th>Codex</th></tr></thead><tbody><tr><td>项目上下文</td><td>仅靠复制粘贴</td><td>自动理解整个代码仓库</td></tr><tr><td>文件操作</td><td>不能直接改文件</td><td>可新建 &#x2F; 修改 &#x2F; 删除文件</td></tr><tr><td>命令执行</td><td>只能给你命令</td><td>可直接执行命令</td></tr><tr><td>多步骤任务</td><td>需要你手动拆解</td><td>可自动规划并执行</td></tr><tr><td>开发位置</td><td>浏览器</td><td>终端 &#x2F; VS Code &#x2F; Cursor</td></tr></tbody></table><p><strong>Codex CLI</strong> 是 OpenAI 提供的一款在终端中运行的 AI 代码助手工具，结合 ChatGPT 的能力，可在命令行和 IDE 中以自然语言生成、审查、重构代码。本文整理了国内环境下的安装前置条件、Codex CLI 安装步骤以及 VS Code 插件安装方法，帮助你快速上手。</p><hr><h2 id="🧠-前置条件"><a href="#🧠-前置条件" class="headerlink" title="🧠 前置条件"></a>🧠 前置条件</h2><p>在开始安装之前，请确保满足以下基本条件：</p><ol><li><strong>ChatGPT Plus &#x2F; Pro &#x2F; Team 会员</strong><br>Codex 目前仅对 ChatGPT 的付费订阅用户开放，免费账户无法使用。这里推荐大家去海鲜市场按月购入team会员（价格在10-20元不等），不过要注意的是，为了防止商家跑路，最好不要一次性购入很长时间的会员。</li><li><strong>科学上网环境</strong><br>国内访问 ChatGPT 及相关服务时，需要能够访问被墙外服务。这个不做推荐，大家自行寻找。</li><li><strong>Node.js 环境（用于 CLI）</strong><br>Codex CLI 基于 Node.js 运行，需要 <strong>Node.js 22+</strong> 版本环境。后文会详细说明安装方法。</li></ol><hr><h2 id="🚀-Codex-CLI-安装步骤"><a href="#🚀-Codex-CLI-安装步骤" class="headerlink" title="🚀 Codex CLI 安装步骤"></a>🚀 Codex CLI 安装步骤</h2><h3 id="1-检查-Node-js-是否已安装"><a href="#1-检查-Node-js-是否已安装" class="headerlink" title="1. 检查 Node.js 是否已安装"></a>1. 检查 Node.js 是否已安装</h3><p>打开终端（macOS &#x2F; Linux &#x2F; Windows PowerShell），执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>若返回版本号 <strong>≥ 22</strong>，则可跳过安装节点。</p><hr><h3 id="2-安装-Node-js（如未安装）"><a href="#2-安装-Node-js（如未安装）" class="headerlink" title="2. 安装 Node.js（如未安装）"></a>2. 安装 Node.js（如未安装）</h3><p>前往 <strong>Node.js 官网</strong> 下载并安装最新版（推荐使用 LTS 或最新 22+ 版本）：</p><p>🔗 Node.js 官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a> </p><p>安装后重新打开终端，再次执行 <code>node -v</code> 确认版本。</p><hr><h3 id="3-安装-Codex-CLI"><a href="#3-安装-Codex-CLI" class="headerlink" title="3. 安装 Codex CLI"></a>3. 安装 Codex CLI</h3><h4 id="🐧-macOS-Linux"><a href="#🐧-macOS-Linux" class="headerlink" title="🐧 macOS &#x2F; Linux"></a>🐧 macOS &#x2F; Linux</h4><p>使用 npm 全局安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @openai/codex@latest</span><br></pre></td></tr></table></figure><blockquote><p>若国内网络较慢，可使用国内镜像加速：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @openai/codex@latest --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>也可以通过 Homebrew 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install codex</span><br><span class="line">``` :contentReference[oaicite:8]&#123;index=8&#125;</span><br></pre></td></tr></table></figure><p>验证安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codex --version</span><br></pre></td></tr></table></figure><p>若输出版本号，则说明安装成功。</p><h4 id="🪟-windows"><a href="#🪟-windows" class="headerlink" title="🪟 windows"></a>🪟 windows</h4><p>Windows 用户同样可以正常使用 Codex CLI，推荐使用 <strong>PowerShell</strong>。</p><ul><li>在开始菜单中搜索 <strong>PowerShell</strong></li><li>右键选择 <strong>“以管理员身份运行”</strong></li></ul><p>执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @openai/codex@latest</span><br></pre></td></tr></table></figure><p>如果遇到下载慢或卡住的问题，建议使用国内 npm 镜像：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @openai/codex@latest --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>验证安装，在 PowerShell 中执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codex --version</span><br></pre></td></tr></table></figure><p><img src="/posts/9975aeb1/image-20260205122856394.png" alt="image-20260205122856394"></p><p>如果能正确输出版本号，说明 Codex CLI 已成功安装。</p><hr><h2 id="🔐-Codex-CLI-登录授权"><a href="#🔐-Codex-CLI-登录授权" class="headerlink" title="🔐 Codex CLI 登录授权"></a>🔐 Codex CLI 登录授权</h2><p>Codex CLI 需要登录授权才能使用。支持两种方式：</p><h3 id="🔹-方式-1-—-使用-ChatGPT-官方账号登录（推荐）"><a href="#🔹-方式-1-—-使用-ChatGPT-官方账号登录（推荐）" class="headerlink" title="🔹 方式 1 — 使用 ChatGPT 官方账号登录（推荐）"></a>🔹 方式 1 — 使用 ChatGPT 官方账号登录（推荐）</h3><p>终端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codex</span><br></pre></td></tr></table></figure><p><img src="/posts/9975aeb1/image-20260205123004216.png" alt="image-20260205123004216"></p><p>首次运行时会弹出链接或二维码（我这里已经登陆过了），让你在浏览器中登录你的 ChatGPT 账号并授权。登录成功后，即可在终端直接使用。授权信息会自动保存，下次无需重复登录。</p><hr><h3 id="🔹-方式-2-—-使用-API-Key（第三方服务）"><a href="#🔹-方式-2-—-使用-API-Key（第三方服务）" class="headerlink" title="🔹 方式 2 — 使用 API Key（第三方服务）"></a>🔹 方式 2 — 使用 API Key（第三方服务）</h3><p>如果你有支持 Codex 模型的第三方 API Key，也可以配置：</p><ol><li>新建配置目录：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.codex</span><br></pre></td></tr></table></figure><ol><li>创建 <code>config.toml</code>（指定 API 服务商和模型）</li><li>创建 <code>auth.json</code> 并填入你的 API Key</li></ol><p>示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;OPENAI_API_KEY&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sk-你的API密钥&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后重新运行 <code>codex</code> 即可。</p><hr><h2 id="🧩-在-VS-Code-中安装-Codex-插件"><a href="#🧩-在-VS-Code-中安装-Codex-插件" class="headerlink" title="🧩 在 VS Code 中安装 Codex 插件"></a>🧩 在 VS Code 中安装 Codex 插件</h2><p>如果你不喜欢命令行交互，实际上这中方式在实际开发中很少用到，我推荐在 <strong>VS Code 中通过插件 UI 使用 Codex</strong>。</p><h3 id="1-打开-VS-Code"><a href="#1-打开-VS-Code" class="headerlink" title="1. 打开 VS Code"></a>1. 打开 VS Code</h3><p>打开 VS Code 编辑器。</p><hr><h3 id="2-安装-Codex-扩展"><a href="#2-安装-Codex-扩展" class="headerlink" title="2. 安装 Codex 扩展"></a>2. 安装 Codex 扩展</h3><ol><li>点击左侧的 <strong>扩展商店（Extensions）</strong></li><li>在搜索框中输入 <strong>Codex</strong></li><li>找到 <strong>OpenAI 官方 Codex 插件</strong> 并点击 <strong>安装</strong>。</li></ol><p><img src="/posts/9975aeb1/image-20260205123303996.png" alt="image-20260205123303996"></p><hr><h3 id="3-登录并使用"><a href="#3-登录并使用" class="headerlink" title="3. 登录并使用"></a>3. 登录并使用</h3><p>安装完成后：</p><ol><li>左侧边栏会出现 Codex 图标</li><li>点击图标并完成登录授权（与 CLI 登录类似）</li><li>授权成功后即可在侧边栏中与 Codex 对话、生成代码</li></ol><p><img src="/posts/9975aeb1/image-20260205123455217.png" alt="image-20260205123455217"></p><p>🛠 你还可以选中代码块 → 右键 → 选择 “Ask Codex” 直接提问当前代码片段的解释或优化建议。</p><p><strong>安装教程到此结束，后续有时间我还会发一些有关codex在代码开发中的实际应用方式以及一些小技巧，供大家交流与学习！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【教程】hexo跨端协同教程</title>
      <link href="/posts/83dcefb7.html"/>
      <url>/posts/83dcefb7.html</url>
      
        <content type="html"><![CDATA[<p>Hexo 是一个快速、高效的静态博客生成框架，主要用于搭建个人博客或技术网站。它允许用户使用 Markdown 编写文章，再由 Hexo 自动生成完整的静态网页。与传统动态博客不同，Hexo 不依赖数据库或后端服务，生成的站点由纯 HTML、CSS 和 JavaScript 组成，访问速度快，安全性高，维护成本低。Hexo 拥有完善的主题和插件生态，支持文章分类、标签、归档、代码高亮等功能，非常适合程序员和技术爱好者记录学习笔记、项目总结或个人思考。通过配合 Git 和静态托管服务，可以实现博客的自动部署和多设备同步，使写作与发布流程更加高效、可控。</p><p>如果你在多台电脑之间切换写博客，例如在多台工作电脑上上都想维护同一个 Hexo 博客，本篇文章将带你一步步完成设置和同步流程，让你的博客在不同电脑之间无缝协作。（有关hexo博客的搭建网上已经有很多优秀的教程了，这里我来推荐几个：<a href="https://blog.csdn.net/2301_79954726/article/details/157688775">Hexo + GitHub Pages 零基础搭建博客详细步骤</a>、 <a href="https://zhuanlan.zhihu.com/p/8488305089">超详细 Hexo + Github Pages 博客搭建教程</a>、 <a href="https://webfem.com/post/hexo">手把手教你搭建 Hexo 博客</a>）</p><hr><h2 id="🎯-为什么需要多台电脑同步博客？"><a href="#🎯-为什么需要多台电脑同步博客？" class="headerlink" title="🎯 为什么需要多台电脑同步博客？"></a>🎯 为什么需要多台电脑同步博客？</h2><p>很多人会遇到这样的情况：手头有多台设备，但博客内容和配置需要保持一致。为避免重复操作、环境不一致或内容丢失，我们需要让 Hexo 博客在不同电脑之间能够方便地同步和更新。</p><hr><h2 id="🔍-同步的核心思路"><a href="#🔍-同步的核心思路" class="headerlink" title="🔍 同步的核心思路"></a>🔍 同步的核心思路</h2><p>要实现多电脑之间的博客同步，关键在于利用 Git 的分支管理机制：</p><ul><li>博客的 <strong>源文件</strong> 和 <strong>生成的静态页面</strong> 分别管理在不同的分支。</li><li>所有博客源文件统一放在一个分支（如 <code>hexo</code> 分支）。</li><li>生成后的静态页面则通过 Hexo 自动部署到另一个分支（如 <code>master</code> 分支）。</li></ul><h3 id="为什么要区分分支？"><a href="#为什么要区分分支？" class="headerlink" title="为什么要区分分支？"></a>为什么要区分分支？</h3><p>Hexo 自带的部署机制会将生成的静态页面推送到一个指定分支。如果这个分支同时也承载源文件，那么每次生成与提交都会混合变更，造成历史混乱。因此：</p><ul><li>使用一个分支来存放源代码（markdown、配置）。</li><li>使用另一个分支来存放静态文件（Hexo 自动生成的 HTML 等）。</li></ul><p>这样，你在不同电脑上都能拉取最新的源文件，生成站点并部署，而不会互相干扰。</p><hr><h2 id="🛠-在老电脑上配置-Hexo"><a href="#🛠-在老电脑上配置-Hexo" class="headerlink" title="🛠 在老电脑上配置 Hexo"></a>🛠 在老电脑上配置 Hexo</h2><p>下面介绍在你已有博客的主电脑上进行必要的设置。</p><h3 id="创建用于源码的分支"><a href="#创建用于源码的分支" class="headerlink" title="创建用于源码的分支"></a>创建用于源码的分支</h3><ol><li>进入你的博客仓库。</li><li>从 GitHub 上新建一个名为 <code>hexo</code> 的分支，这时，github会将master分支中的静态网页内容克隆到hexo分支。</li></ol><p><img src="/posts/83dcefb7/%E6%88%AA%E5%9B%BE20260205125043.png" alt="截图20260205125043"></p><h3 id="准备推送博客源码"><a href="#准备推送博客源码" class="headerlink" title="准备推送博客源码"></a>准备推送博客源码</h3><ol><li><p>克隆远程仓库到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:你的用户名/你的仓库名.git</span><br><span class="line">git fetch origin <span class="comment">#同步远程数据</span></span><br><span class="line">git checkout hexo <span class="comment">#切换到开发分支</span></span><br></pre></td></tr></table></figure></li><li><p>删除所有文件，只保留 <code>.git</code> 文件夹（将静态网页文件删除掉）。</p></li><li><p>把你现有博客的所有内容（除 <code>.deploy_git</code> 文件夹）复制进来，<strong>如果你配置了主题，注意把Theme文件夹中的.git文件也要删除掉（这一步十分重要，git不允许嵌套上传，不删除会导致报错）</strong>。</p></li><li><p>编辑 <code>.gitignore</code> 文件（在当前目录，目的是在push时忽略这些文件；如果项目根目录中没有这个文件，请手动创建一个），将以下内容复制进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure></li><li><p>提交并推送所有源码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;initial blog source&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure></li></ol><p>这样一来，你的博客源文件就保存在 GitHub 的 <code>hexo</code> 分支里了。</p><hr><h2 id="💻-在新电脑上搭建-Hexo-环境"><a href="#💻-在新电脑上搭建-Hexo-环境" class="headerlink" title="💻 在新电脑上搭建 Hexo 环境"></a>💻 在新电脑上搭建 Hexo 环境</h2><p>当你换用另一台新电脑，以下是完整的步骤：</p><h3 id="克隆博客源码"><a href="#克隆博客源码" class="headerlink" title="克隆博客源码"></a>克隆博客源码</h3><p>克隆你博客的源码分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:你的用户名/你的仓库名.git</span><br><span class="line">git fetch origin <span class="comment">#同步远程数据</span></span><br><span class="line">git checkout hexo <span class="comment">#切换到开发分支</span></span><br></pre></td></tr></table></figure><p>此时仓库就在本地了。</p><h3 id="安装-Node-js-和-Hexo"><a href="#安装-Node-js-和-Hexo" class="headerlink" title="安装 Node.js 和 Hexo"></a>安装 Node.js 和 Hexo</h3><p><strong>确保安装 Node.js 与 npm；</strong></p><p>进入刚刚克隆下来的<strong>仓库文件夹内</strong>，安装 Hexo 和相关依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>现在，你的新电脑就已经具备 Hexo 的运行环境了。</p><hr><h2 id="🔄-日常更新与同步流程"><a href="#🔄-日常更新与同步流程" class="headerlink" title="🔄 日常更新与同步流程"></a>🔄 日常更新与同步流程</h2><p>无论你在哪台设备上写博客，都可以按以下流程来保证内容最新：</p><h3 id="同步远程仓库最新内容"><a href="#同步远程仓库最新内容" class="headerlink" title="同步远程仓库最新内容"></a>同步远程仓库最新内容</h3><p>在写文章之前：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin hexo <span class="comment">#同步远程分支</span></span><br></pre></td></tr></table></figure><h3 id="编写文章-提交"><a href="#编写文章-提交" class="headerlink" title="编写文章 &amp; 提交"></a>编写文章 &amp; 提交</h3><p>写完文章后：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hexo四件套：</span></span><br><span class="line">hexo c <span class="comment">#清除缓存</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo s <span class="comment">#本地预览</span></span><br><span class="line">hexo d <span class="comment">#远程部署</span></span><br><span class="line"><span class="comment">#git三件套：</span></span><br><span class="line">git add . </span><br><span class="line">git commit -m <span class="string">&quot;更新日志&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><p>这样可以确保博客源文件和静态页面都分别更新到了对应的分支，如果你想要更方便一点，可以将hexo分支设置为默认分支（这样可以在版本同步时少打几个字，不过我认为没必要，还容易影响到其他关联的软件）。</p><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="取消vercel除生产分支外的自动部署"><a href="#取消vercel除生产分支外的自动部署" class="headerlink" title="取消vercel除生产分支外的自动部署"></a>取消vercel除生产分支外的自动部署</h3><p>如果你也是用vercel自动部署的，可能会发现在hexo分支更新之后，vercel会自动进行预览部署操作，实际上我们是不需要这一步多余操作的（浪费资源）；如果想要关闭这个功能，请进入你的vercel项目设置 - &gt; Environments，把Preview设置为Disabled即可。</p><p><img src="/posts/83dcefb7/mmexport1770620438174.png" alt="mmexport1770620438174"></p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为昇腾HCCL算法注册与执行机制概述</title>
      <link href="/posts/58974538.html"/>
      <url>/posts/58974538.html</url>
      
        <content type="html"><![CDATA[<p>HCCL（Huawei Collective Communication Library）是华为为昇腾（Ascend）AI 处理器提供的集合通信库，用于分布式深度学习训练中多卡、多机之间的高速数据通信，它实现了 AllReduce、AllGather、Broadcast 等常见集合通信算子，并针对昇腾硬件和高速互联进行了深度优化，作用类似于 NVIDIA GPU 生态中的 NCCL，常用于 MindSpore 及 Ascend 生态下的大规模模型训练。</p><h2 id="一、整体架构"><a href="#一、整体架构" class="headerlink" title="一、整体架构"></a>一、整体架构</h2><h3 id="1-核心组件"><a href="#1-核心组件" class="headerlink" title="1. 核心组件"></a>1. 核心组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">src/domain/collective_communication/algorithm/</span><br><span class="line">├── pub_inc/</span><br><span class="line">│   └── coll_executor_base.h            # 执行器基类定义</span><br><span class="line">├── impl/</span><br><span class="line">│   ├── operator/</span><br><span class="line">│   │   └── custom_all_reduce_operator.cc   # 算子实现</span><br><span class="line">│   └── coll_executor/</span><br><span class="line">│       ├── registry/</span><br><span class="line">│       │   ├── coll_alg_exec_registry.h    # 注册表定义</span><br><span class="line">│       │   └── coll_alg_exec_registry.cc   # 注册表实现</span><br><span class="line">│       └── coll_all_reduce/</span><br><span class="line">│           └── coll_custom_*_executor.cc    # 具体执行器实现</span><br></pre></td></tr></table></figure><h3 id="2-类层次结构"><a href="#2-类层次结构" class="headerlink" title="2. 类层次结构"></a>2. 类层次结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CollExecutorBase</span> &#123;              <span class="comment">// 基类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HcclResult <span class="title">Orchestrate</span><span class="params">(...)</span></span>;   <span class="comment">// 核心接口</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> HcclResult <span class="title">CalcResRequest</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollCommExecutor</span> : <span class="keyword">public</span> CollExecutorBase &#123;  <span class="comment">// 通用实现</span></span><br><span class="line">    <span class="comment">// 公共功能实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CollCustomSmallAllReduceMeshExecutor</span> : <span class="keyword">public</span> CollCommExecutor &#123;  <span class="comment">// 具体算法</span></span><br><span class="line">    <span class="comment">// 具体算法实现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二、注册机制"><a href="#二、注册机制" class="headerlink" title="二、注册机制"></a>二、注册机制</h2><h3 id="1-注册宏定义"><a href="#1-注册宏定义" class="headerlink" title="1. 注册宏定义"></a>1. 注册宏定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// coll_alg_exec_registry.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER_EXEC(tag, name, collExecBase) \</span></span><br><span class="line"><span class="meta">    static CollExecCreator collExecCreator = \</span></span><br><span class="line"><span class="meta">        [](const HcclDispatcher dispatcher, std::unique_ptr<span class="string">&lt;TopoMatcher&gt;</span> &amp;topoMatcher) \</span></span><br><span class="line"><span class="meta">            -&gt; CollExecutorBase * &#123; \</span></span><br><span class="line"><span class="meta">                return new collExecBase(dispatcher, topoMatcher); \</span></span><br><span class="line"><span class="meta">            &#125;; \</span></span><br><span class="line"><span class="meta">    static HcclResult ret = \</span></span><br><span class="line"><span class="meta">        CollAlgExecRegistry::Instance().Register(tag, collExecCreator)</span></span><br></pre></td></tr></table></figure><h3 id="2-注册表实现"><a href="#2-注册表实现" class="headerlink" title="2. 注册表实现"></a>2. 注册表实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CollAlgExecRegistry</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::map&lt;std::string, CollExecCreator&gt; execCreators_;  <span class="comment">// 存储表</span></span><br><span class="line">    <span class="type">static</span> CollAlgExecRegistry globalExecRegistry;         <span class="comment">// 全局单例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> CollAlgExecRegistry&amp; <span class="title">Instance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">HcclResult <span class="title">Register</span><span class="params">(<span class="type">const</span> std::string&amp; tag, <span class="type">const</span> CollExecCreator&amp; creator)</span></span>;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;CollExecutorBase&gt; <span class="title">GetAlgExec</span><span class="params">(<span class="type">const</span> std::string&amp; tag, ...)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><h3 id="1-编译期机制"><a href="#1-编译期机制" class="headerlink" title="1. 编译期机制"></a>1. 编译期机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">源文件编译过程：</span><br><span class="line">custom_executor.cc</span><br><span class="line">    -&gt; custom_executor.o</span><br><span class="line">       ├── .text段：执行器实现代码</span><br><span class="line">       ├── .init段：注册初始化代码</span><br><span class="line">       └── .data段：静态对象数据</span><br></pre></td></tr></table></figure><h3 id="2-内存布局"><a href="#2-内存布局" class="headerlink" title="2. 内存布局"></a>2. 内存布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">最终可执行文件布局：</span><br><span class="line">.init段：</span><br><span class="line">    |- 所有REGISTER_EXEC生成的初始化代码</span><br><span class="line">.data段：</span><br><span class="line">    |- CollAlgExecRegistry单例</span><br><span class="line">    |- 其他静态数据</span><br><span class="line">.text段：</span><br><span class="line">    |- 所有executor实现代码</span><br></pre></td></tr></table></figure><h3 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 程序启动前：静态初始化</span></span><br><span class="line"><span class="type">static</span> CollExecCreator creator = [...];     <span class="comment">// 创建函数对象</span></span><br><span class="line"><span class="type">static</span> HcclResult ret = Registry::<span class="built_in">Register</span>(); <span class="comment">// 注册到表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 运行时选择算法</span></span><br><span class="line"><span class="function">HcclResult <span class="title">CustomAllReduceOperator::SelectAlg</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dataSize &lt;= SMALL_COUNT) &#123;</span><br><span class="line">        algName = <span class="string">&quot;CustomSmallAllReduceMeshExecutor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建执行器实例</span></span><br><span class="line"><span class="keyword">auto</span> executor = CollAlgExecRegistry::<span class="built_in">Instance</span>().<span class="built_in">GetAlgExec</span>(algName, ...);</span><br></pre></td></tr></table></figure><h2 id="四、关键特性"><a href="#四、关键特性" class="headerlink" title="四、关键特性"></a>四、关键特性</h2><h3 id="1-静态初始化特性"><a href="#1-静态初始化特性" class="headerlink" title="1. 静态初始化特性"></a>1. 静态初始化特性</h3><ul><li>利用C++静态对象构造顺序</li><li>程序启动前完成注册</li><li>零运行时注册开销</li></ul><h3 id="2-符号可见性控制"><a href="#2-符号可见性控制" class="headerlink" title="2. 符号可见性控制"></a>2. 符号可见性控制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;  <span class="comment">// 匿名命名空间</span></span><br><span class="line">    <span class="type">static</span> CollExecCreator creator = [...];  <span class="comment">// 对外部不可见</span></span><br><span class="line">    <span class="type">static</span> HcclResult ret = [...];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-运行时灵活性"><a href="#3-运行时灵活性" class="headerlink" title="3. 运行时灵活性"></a>3. 运行时灵活性</h3><ul><li>通过字符串标识符动态选择算法</li><li>支持条件选择不同实现</li><li>易于扩展新算法</li></ul><h2 id="五、优势对比"><a href="#五、优势对比" class="headerlink" title="五、优势对比"></a>五、优势对比</h2><h3 id="1-对比传统静态链接"><a href="#1-对比传统静态链接" class="headerlink" title="1. 对比传统静态链接"></a>1. 对比传统静态链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">静态链接库：</span><br><span class="line">- 需要导出符号</span><br><span class="line">- 编译时确定</span><br><span class="line">- 按需链接.o文件</span><br><span class="line"></span><br><span class="line">HCCL注册机制：</span><br><span class="line">- 符号可完全隐藏</span><br><span class="line">- 运行时动态选择</span><br><span class="line">- 注册表统一管理</span><br></pre></td></tr></table></figure><h3 id="2-设计优势"><a href="#2-设计优势" class="headerlink" title="2. 设计优势"></a>2. 设计优势</h3><ol><li><p>更好的封装性</p><ul><li>实现细节完全隐藏</li><li>不需要导出符号</li></ul></li><li><p>更灵活的扩展性</p><ul><li>新增算法无需修改现有代码</li><li>不需要修改编译系统</li></ul></li><li><p>更好的运行时特性</p><ul><li>支持动态算法选择</li><li>统一的管理机制</li></ul></li></ol><h2 id="六、使用示例"><a href="#六、使用示例" class="headerlink" title="六、使用示例"></a>六、使用示例</h2><h3 id="1-实现新执行器"><a href="#1-实现新执行器" class="headerlink" title="1. 实现新执行器"></a>1. 实现新执行器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// custom_executor.cc</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomExecutor</span> : <span class="keyword">public</span> CollCommExecutor &#123;</span><br><span class="line">    <span class="function">HcclResult <span class="title">Orchestrate</span><span class="params">(...)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现算法逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册到框架</span></span><br><span class="line"><span class="built_in">REGISTER_EXEC</span>(<span class="string">&quot;CustomExecutor&quot;</span>, Custom, CustomExecutor);</span><br></pre></td></tr></table></figure><h3 id="2-在算子中使用"><a href="#2-在算子中使用" class="headerlink" title="2. 在算子中使用"></a>2. 在算子中使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HcclResult <span class="title">CustomOperator::SelectAlg</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (meetCondition) &#123;</span><br><span class="line">        algName = <span class="string">&quot;CustomExecutor&quot;</span>;  <span class="comment">// 选择执行器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HCCL_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个机制结合了C++的静态初始化特性和运行时的灵活性，提供了一个优雅的算法注册和管理方案。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】混合整数规划（MIP, mixed integer programming）</title>
      <link href="/posts/82fbdb.html"/>
      <url>/posts/82fbdb.html</url>
      
        <content type="html"><![CDATA[<p><strong>标签</strong>: #数学优化 #线性规划 #高等难度 #组合优化 #决策优化</p><p><strong>#核心思想:</strong> 在满足线性约束条件下，优化包含连续变量和整数变量的线性目标函数，解决复杂的组合优化问题。</p><p><strong>#算法原理:</strong><br>MIP是线性规划(LP)的扩展，其中部分变量被限制为整数值。通过分支定界法、割平面法等方法，系统地在可行解空间中搜索最优解，结合线性松弛和整数约束处理来找到满足所有约束的最佳整数解。</p><p><strong>#复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>: NP难问题，最坏情况下指数级复杂度</li><li><strong>空间复杂度</strong>: O(2ⁿ) 在最坏情况下，其中n为整数变量个数</li></ul><p><strong>#代码实现:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ilcplex/ilocplex.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">ILOSTLBEGIN</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveMIP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IloEnv env;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">IloModel <span class="title">model</span><span class="params">(env)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义变量：连续变量x和整数变量y</span></span><br><span class="line">        <span class="function">IloNumVar <span class="title">x</span><span class="params">(env, <span class="number">0.0</span>, <span class="number">40.0</span>, ILOFLOAT, <span class="string">&quot;x&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">IloIntVar <span class="title">y</span><span class="params">(env, <span class="number">0</span>, <span class="number">100</span>, <span class="string">&quot;y&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加约束</span></span><br><span class="line">        model.<span class="built_in">add</span>(-x + <span class="number">2</span>*y &lt;= <span class="number">7</span>);</span><br><span class="line">        model.<span class="built_in">add</span>(<span class="number">2</span>*x + y &lt;= <span class="number">14</span>);</span><br><span class="line">        model.<span class="built_in">add</span>(<span class="number">2</span>*x - y &lt;= <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置目标函数：最大化 x + y</span></span><br><span class="line">        model.<span class="built_in">add</span>(<span class="built_in">IloMaximize</span>(env, x + y));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求解</span></span><br><span class="line">        <span class="function">IloCplex <span class="title">cplex</span><span class="params">(model)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (cplex.<span class="built_in">solve</span>()) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;最优值: &quot;</span> &lt;&lt; cplex.<span class="built_in">getObjValue</span>() &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; cplex.<span class="built_in">getValue</span>(x) &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;y = &quot;</span> &lt;&lt; cplex.<span class="built_in">getValue</span>(y) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (IloException&amp; e) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Concert exception: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    env.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#执行流程图:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始 → 问题建模 → 线性松弛求解 → 选择分支变量 → 分支创建子问题</span><br><span class="line">    ↓                              ↑</span><br><span class="line">整数解找到 ← 检查整数性 ← 求解子问题 ← 剪枝不可行解</span><br><span class="line">    ↓</span><br><span class="line">输出最优解 → 结束</span><br></pre></td></tr></table></figure><p><strong>#适用场景:</strong></p><ul><li>生产调度和排程优化</li><li>资源分配和投资组合优化</li><li>设施选址和路径规划</li><li>机器学习中的特征选择</li></ul><p><strong>#优缺点:</strong></p><ul><li>✅ 优点：能够精确建模复杂现实问题，提供数学最优性保证</li><li>❌ 缺点：计算复杂度高，大规模问题求解时间长，对建模技巧要求高</li></ul><p><strong>#变种与改进:</strong></p><ul><li>MILP（混合整数线性规划）</li><li>MIQP（混合整数二次规划）</li><li>MINLP（混合整数非线性规划）</li><li>启发式MIP：如遗传算法、模拟退火与MIP结合</li><li>并行MIP：多线程分支定界</li></ul><p><strong>#注意事项:</strong></p><ul><li>问题规模较大时需要设置求解时间限制</li><li>选择合适的求解器参数和策略很重要</li><li>模型 formulation 对求解效率影响很大</li><li>需要注意数值稳定性和精度问题</li></ul><p><strong>#参考资料:</strong><br><a href="https://www.ibm.com/docs/en/icos/20.1.0">CPLEX优化教程 - IBM</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法笔记】广度优先搜索算法（BFS, breadth-first search）</title>
      <link href="/posts/f9717167.html"/>
      <url>/posts/f9717167.html</url>
      
        <content type="html"><![CDATA[<p><strong>标签</strong>: #图算法 #搜索算法 #中等难度 #路径查找 #连通性分析</p><p><strong>#核心思想:</strong> 从起始节点开始，逐层向外扩展探索所有可达节点，确保先访问距离起点更近的节点。</p><p><strong>#算法原理:</strong><br>BFS通过队列实现层次遍历，首先将起始节点入队并标记已访问，然后不断从队列中取出节点，访问其所有未访问的相邻节点并入队，重复此过程直到队列为空。</p><p><strong>#复杂度分析</strong></p><ul><li><strong>时间复杂度</strong>: O(V + E)，其中V为顶点数，E为边数</li><li><strong>空间复杂度</strong>: O(V)，最坏情况下需要存储所有节点</li></ul><p><strong>#代码实现:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(<span class="type">int</span> startNode, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(startNode);</span><br><span class="line">    visited[startNode] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> currentNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;访问节点: &quot;</span> &lt;&lt; currentNode &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有邻居节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> neighbor : graph[currentNode]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">                visited[neighbor] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>#执行流程图:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开始 → 起始节点入队 → 队列非空? → 是 → 出队并访问 → 所有未访问邻居入队</span><br><span class="line">                              ↓</span><br><span class="line">                              否 → 结束</span><br></pre></td></tr></table></figure><p><strong>#适用场景:</strong></p><ul><li>无权图的最短路径查找</li><li>连通分量检测</li><li>层级遍历树或图结构</li><li>迷宫求解问题</li><li>社交网络中的好友推荐</li></ul><p><strong>#优缺点:</strong></p><ul><li>✅ 优点：能找到最短路径（在无权图中），实现简单</li><li>❌ 缺点：空间复杂度较高，不适合深度很大的图</li></ul><p><strong>#变种与改进:</strong></p><ul><li>双向BFS：从起点和终点同时开始搜索</li><li>启发式BFS：结合估价函数优化搜索方向</li><li>多源BFS：从多个起点同时开始搜索</li></ul><p><strong>#注意事项:</strong></p><ul><li>必须标记已访问节点，避免重复访问和死循环</li><li>对于大规模图，需要注意队列的内存使用</li><li>在加权图中BFS不能保证找到最短路径</li></ul><p><strong>#参考资料:</strong></p><p><a href="https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/">BFS - GeeksforGeeks</a></p><p><a href="https://www.bilibili.com/video/BV1uCH1eoEYP/?spm_id_from=333.337.search-card.all.click">BFS - Bilibili </a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Claude Code 学习笔记</title>
      <link href="/posts/57c84b4f.html"/>
      <url>/posts/57c84b4f.html</url>
      
        <content type="html"><![CDATA[<p><strong>Claude Code</strong> 是人工智能助手Claude具备的代码理解、生成和优化能力的统称，它基于大型语言模型训练而成，能够处理多种编程语言（如Python、C++、Java等）的编程任务。具体而言，Claude Code能够分析用户需求并生成相应的代码片段，调试和解释现有代码的逻辑错误，优化算法实现以提高性能，在不同编程语言之间进行转换，以及生成技术文档和测试用例。它深度理解编程范式、数据结构和算法，并能结合具体应用场景（如网络优化、数学建模、系统设计等）提供专业级编码解决方案。Claude Code的特点在于能够上下文关联地理解复杂需求，提供符合工程最佳实践的代码，同时给出清晰的技术解释，相当于一个具备全栈开发能力的AI编程助手。</p><h2 id="一、常用指令行"><a href="#一、常用指令行" class="headerlink" title="一、常用指令行"></a>一、常用指令行</h2><ol><li><code>/init</code> - 初始化阅读工程，输出到md文件</li><li>两次按<code>shift+tab</code> 进入plan mode（做计划）</li><li><code>think hard/ harder/ ultrathink</code> -代表思考力度（越右消耗token越多）</li><li><code>creat a task to xxxx</code> - 创建todo list，分步骤执行操作</li><li><code>add a task to xxx</code> - 添加 task</li><li><code>clear</code> - 清除</li><li><code>compact</code> - 主动压缩context</li></ol><h2 id="二、Context-Manage"><a href="#二、Context-Manage" class="headerlink" title="二、Context Manage"></a>二、Context Manage</h2><h3 id="1-局部上下文管理"><a href="#1-局部上下文管理" class="headerlink" title="1.局部上下文管理"></a>1.局部上下文管理</h3><p>（1）插入内容（框选、直接复制进来）</p><p>（2）插入文件（@+文件名、@&#x2F;+目录名）</p><p>（3）图片（Ctrl+v）</p><h3 id="2-整体上下文管理"><a href="#2-整体上下文管理" class="headerlink" title="2.整体上下文管理"></a>2.整体上下文管理</h3><p>（1）恢复上次对话（<code>claude -c</code>，在进入cc之前）</p><p>（2）选择历史会话（<code>claude -r</code>，同上；<code>/resume</code>，在进入cc之后）</p><h3 id="3-记忆管理"><a href="#3-记忆管理" class="headerlink" title="3.记忆管理"></a>3.记忆管理</h3><p>（1）添加记忆&#x2F;规则（# + 内容）&lt;存储到文件中&gt;</p><h2 id="三、工具与MCP"><a href="#三、工具与MCP" class="headerlink" title="三、工具与MCP"></a>三、工具与MCP</h2><h3 id="1-内置工具"><a href="#1-内置工具" class="headerlink" title="1.内置工具"></a>1.内置工具</h3><p>（1）bash超时问题：通过环境变量调整变大 <code>bash</code></p><p>（2）可以编辑jupyter notebook</p><p>（3）可以贴链接url（可以直接抓取网页内容）<code>webFetch</code></p><h3 id="2-自定义斜杠命令"><a href="#2-自定义斜杠命令" class="headerlink" title="2.自定义斜杠命令"></a>2.自定义斜杠命令</h3><p>（1）把经常打的那句话变成命令,以下是操作方法（arguments可有可无）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建个人命令</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.claude/commands</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;xxxxxxxxxxxxx:<span class="variable">$ARGUMENTS</span>&quot;</span> &gt; ~/.claude/commands/xxx.md</span><br><span class="line"><span class="comment">#md的文件名就是自定义命令名</span></span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/xxx [arguments]</span><br></pre></td></tr></table></figure><p>（2）可以调用MCP服务里面的提示词</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/mcp__mcp名字__斜杠命令名 [arguments]</span><br></pre></td></tr></table></figure><h3 id="3-Model-Context-Protocol"><a href="#3-Model-Context-Protocol" class="headerlink" title="3. Model Context Protocol"></a>3. Model Context Protocol</h3><p>在Claude执行之前进行下述操作：</p><p><strong>（1）添加本地 stdio 服务器</strong></p><p>Stdio 服务器作为本地进程在您的机器上运行。它们非常适合需要直接系统访问或自定义脚本的工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">claude mcp add &lt;name&gt; &lt;<span class="built_in">command</span>&gt; [args...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例：添加 Airtable 服务器</span></span><br><span class="line">claude mcp add airtable --<span class="built_in">env</span> AIRTABLE_API_KEY=YOUR_KEY \</span><br><span class="line">  -- npx -y airtable-mcp-server</span><br></pre></td></tr></table></figure><p><strong>（2）添加远程 SSE 服务器</strong></p><p>SSE（服务器发送事件）服务器提供实时流连接。许多云服务使用此功能进行实时更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">claude mcp add --transport sse &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例：连接到 Linear</span></span><br><span class="line">claude mcp add --transport sse linear https://mcp.linear.app/sse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带身份验证标头的示例</span></span><br><span class="line">claude mcp add --transport sse private-api https://api.company.com/mcp \</span><br><span class="line">  --header <span class="string">&quot;X-API-Key: your-key-here&quot;</span></span><br></pre></td></tr></table></figure><p><strong>（3）添加远程 HTTP 服务器</strong></p><p>HTTP 服务器使用标准的请求&#x2F;响应模式。大多数 REST API 和 Web 服务使用此传输方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">claude mcp add --transport http &lt;name&gt; &lt;url&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际示例：连接到 Notion</span></span><br><span class="line">claude mcp add --transport http notion https://mcp.notion.com/mcp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带 Bearer 令牌的示例</span></span><br><span class="line">claude mcp add --transport http secure-api https://api.example.com/mcp \</span><br><span class="line">  --header <span class="string">&quot;Authorization: Bearer your-token&quot;</span></span><br></pre></td></tr></table></figure><p><strong>（4）管理MCP</strong></p><p>配置完成后，使用以下命令管理的 MCP 服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有配置的服务器</span></span><br><span class="line">claude mcp list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取特定服务器的详细信息</span></span><br><span class="line">claude mcp get github</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除服务器</span></span><br><span class="line">claude mcp remove github</span><br><span class="line"></span><br><span class="line"><span class="comment"># （在 Claude Code 中）检查服务器状态</span></span><br><span class="line">/mcp</span><br></pre></td></tr></table></figure><p><strong>（5） <a href="https://docs.anthropic.com/zh-CN/docs/claude-code/mcp#mcp-%E5%AE%89%E8%A3%85%E8%8C%83%E5%9B%B4">MCP 安装范围</a></strong></p><p>MCP 服务器可以在三个不同的范围级别配置，每个级别都有不同的目的来管理服务器可访问性和共享。了解这些范围有助于确定为特定需求配置服务器的最佳方式。</p><ul><li><strong>本地范围</strong>：个人服务器、实验性配置或特定于一个项目的敏感凭据</li><li><strong>项目范围</strong>：团队共享服务器、项目特定工具或协作所需的服务</li><li><strong>用户范围</strong>：多个项目需要的个人实用程序、开发工具或经常使用的服务</li></ul><h2 id="四、实践"><a href="#四、实践" class="headerlink" title="四、实践"></a>四、实践</h2><h3 id="1-Work-Flow"><a href="#1-Work-Flow" class="headerlink" title="1. Work Flow"></a>1. Work Flow</h3><p>（1）<code>CLAUDE.md</code> <code>/init</code></p><p>（2）按<code>ESC</code>中断操作，而不损失上下文；按两下<code> ESC</code>清除当前操作输出内容</p><p>（3）<code>Shift+Tab</code>进入自动接受模式</p><p>（4）可以让它把<strong>问题列表</strong>存储到各个<code>.md</code>文件中，以便项目迁移和上下文存储</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 学习笔记</title>
      <link href="/posts/d87f7e0c.html"/>
      <url>/posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<p><strong>Markdown</strong>是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 <code>HTML</code>、<code>PDF</code> 以及本身的<code> .md</code> 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如<a href="https://github.com/" title="你好呀">Github</a><strong>、</strong><code>Wikipedia</code><strong>、</strong><code>简书</code>**等。</p><h2 id="一、标题语法（-）"><a href="#一、标题语法（-）" class="headerlink" title="一、标题语法（#）"></a>一、标题语法（<code>#</code>）</h2><p>要创建标题，请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。</p><p>不同的 Markdown 应用程序处理 # 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 # 和标题之间进行分隔。</p><h2 id="二、段落语法"><a href="#二、段落语法" class="headerlink" title="二、段落语法"></a>二、段落语法</h2><p><strong>不要用空格（spaces）或制表符（ tabs）缩进段落。</strong></p><h2 id="三、换行语法（）"><a href="#三、换行语法（）" class="headerlink" title="三、换行语法（&lt;br&gt;）"></a>三、换行语法（<code>&lt;br&gt;</code>）</h2><p>在一行的末尾添加两个或多个空格，然后按回车键,即可创建一个换行(<code>&lt;br&gt;</code>)。</p><p>几乎每个 Markdown 应用程序都支持两个或多个空格进行换行，称为 <code>结尾空格（trailing whitespace)</code> 的方式，但这是有争议的，因为很难在编辑器中直接看到空格，并且很多人在每个句子后面都会有意或无意地添加两个空格。由于这个原因，你可能要使用除结尾空格以外的其它方式来换行。幸运的是，几乎每个 Markdown 应用程序都支持另一种换行方式：HTML 的 <code>&lt;br&gt;</code> 标签。</p><h2 id="四、强调语法"><a href="#四、强调语法" class="headerlink" title="四、强调语法(*)"></a>四、强调语法(<code>*</code>)</h2><h3 id="1、粗体（-）"><a href="#1、粗体（-）" class="headerlink" title="1、粗体（**）"></a>1、粗体（**）</h3><p>要加粗文本，请在单词或短语的前后各添加两个星号**（asterisks）。如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号（asterisks）。</p><p><strong>加粗文字</strong></p><h3 id="2、斜体（-）"><a href="#2、斜体（-）" class="headerlink" title="2、斜体（*）"></a>2、斜体（*）</h3><p>要用斜体显示文本，请在单词或短语前后添加一个星号（asterisk）。要斜体突出单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p><p><em>斜体文字</em></p><h3 id="3、粗体-斜体（-）"><a href="#3、粗体-斜体（-）" class="headerlink" title="3、粗体&amp;斜体（***）"></a>3、粗体&amp;斜体（***）</h3><p>要同时用粗体和斜体突出显示文本，请在单词或短语的前后各添加三个星号或下划线。要加粗并用斜体显示单词或短语的中间部分，请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p><h2 id="五、引用语法"><a href="#五、引用语法" class="headerlink" title="五、引用语法(&gt;)"></a>五、引用语法(<code>&gt;</code>)</h2><p>要创建块引用，请在段落前添加一个 <code>&gt;</code> 符号。</p><h4 id="多个段落的块引用"><a href="#多个段落的块引用" class="headerlink" title="多个段落的块引用"></a>多个段落的块引用</h4><p>块引用可以包含多个段落。为段落之间的空白行添加一个 &gt; 符号。</p><h4 id="嵌套块引用"><a href="#嵌套块引用" class="headerlink" title="嵌套块引用"></a>嵌套块引用</h4><p>块引用可以嵌套。在要嵌套的段落前添加一个 &gt;&gt; 符号。</p><h2 id="六、列表语法-1"><a href="#六、列表语法-1" class="headerlink" title="六、列表语法(1. - * +)"></a>六、列表语法(<code>1.</code> <code>- * +</code>)</h2><h3 id="1、有序列表"><a href="#1、有序列表" class="headerlink" title="1、有序列表"></a>1、有序列表</h3><p>要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。</p><ol><li>hhh</li><li>hhh</li><li>hhh</li></ol><h3 id="2、无序列表"><a href="#2、无序列表" class="headerlink" title="2、无序列表"></a>2、无序列表</h3><p>要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。</p><h3 id="3、在列表中嵌套其他元素"><a href="#3、在列表中嵌套其他元素" class="headerlink" title="3、在列表中嵌套其他元素"></a>3、在列表中嵌套其他元素</h3><p>要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进<strong>四个空格</strong>或<strong>一个制表符（tab）</strong>。</p><h2 id="七、代码语法"><a href="#七、代码语法" class="headerlink" title="七、代码语法(&#96;&#96;&#96;)"></a>七、代码语法(&#96;&#96;&#96;)</h2><p>要将单词或短语表示为代码，请将其包裹在反引号 (&#96;&#96;&#96;) 中。</p><table><thead><tr><th>Markdown语法</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>At the command prompt, type </code>nano<code>.</code></td><td><code>At the command prompt, type &lt;code&gt;nano&lt;/code&gt;.</code></td><td>At the command prompt, type <code>nano</code>.</td></tr></tbody></table><h3 id="转义反引号"><a href="#转义反引号" class="headerlink" title="转义反引号"></a>转义反引号</h3><p>如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(&#96;&#96;&#96;&#96;)中。</p><table><thead><tr><th>Markdown语法</th><th>HTML</th><th>预览效果</th></tr></thead><tbody><tr><td><code>Use `code` in your Markdown file.</code></td><td><code>&lt;code&gt;Use </code>code<code> in your Markdown file.&lt;/code&gt;</code></td><td><code>Use </code>code<code> in your Markdown file.</code></td></tr></tbody></table><h3 id="代码块"><a href="#代码块" class="headerlink" title="#代码块"></a><a href="https://markdown.com.cn/basic-syntax/code.html#%E4%BB%A3%E7%A0%81%E5%9D%97">#</a>代码块</h3><p>要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;html&gt;</span><br><span class="line">  &amp;lt;head&gt;</span><br><span class="line">  &amp;lt;/head&gt;</span><br><span class="line">&amp;lt;/html&gt;</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;html&gt;</span><br><span class="line">  &amp;lt;head&gt;</span><br><span class="line">  &amp;lt;/head&gt;</span><br><span class="line">&amp;lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> 要创建不用缩进的代码块，请使用 <a href="https://markdown.com.cn/extended-syntax/fenced-code-blocks.html">围栏式代码块（fenced code blocks）</a>.</p><h2 id="八、分割线语法"><a href="#八、分割线语法" class="headerlink" title="八、分割线语法(*** --- ___)"></a>八、分割线语法(<code>***</code> <code>---</code> <code>___</code>)</h2><p>要创建分隔线，请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) ，并且不能包含其他内容。</p><p>示例：</p><hr><hr><hr><h2 id="九、链接语法"><a href="#九、链接语法" class="headerlink" title="九、链接语法([](&quot;&quot;))"></a>九、链接语法(<code>[](&quot;&quot;)</code>)</h2><p>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。</p><p>超链接Markdown语法代码：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><h3 id="1、给链接加定义"><a href="#1、给链接加定义" class="headerlink" title="1、给链接加定义"></a>1、给链接加定义</h3><p>链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。lg：<a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a></p><h3 id="2、网址和Email地址"><a href="#2、网址和Email地址" class="headerlink" title="2、网址和Email地址"></a>2、网址和Email地址</h3><p>使用尖括号（&lt;&gt;）可以很方便地把URL或者email地址变成可点击的链接。</p><p><a href="https://markdown.com.cn/">https://markdown.com.cn</a></p><h3 id="3、带格式化的链接"><a href="#3、带格式化的链接" class="headerlink" title="3、带格式化的链接"></a>3、带格式化的链接</h3><p><a href="https://markdown.com.cn/basic-syntax/links.html#emphasis">强调</a> 链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I love supporting the **[EFF](https://eff.org)**.</span><br><span class="line">This is the *[Markdown Guide](https://www.markdownguide.org)*.</span><br><span class="line">See the section on [`code`](#code).</span><br></pre></td></tr></table></figure><p>渲染效果如下：</p><p>I love supporting the <strong><a href="https://eff.org/">EFF (opens new window)</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide (opens new window)</a></em>.<br>See the section on <a href="https://markdown.com.cn/basic-syntax/links.html#code"><code>code</code></a>.</p><h3 id="4、引用类型链接"><a href="#4、引用类型链接" class="headerlink" title="4、引用类型链接"></a>4、引用类型链接</h3><h4 id="链接的第一部分格式"><a href="#链接的第一部分格式" class="headerlink" title="链接的第一部分格式"></a>链接的第一部分格式</h4><p>引用类型的链接的第一部分使用两组括号进行格式设置。第一组方括号包围应显示为链接的文本。第二组括号显示了一个标签，该标签用于指向您存储在文档其他位置的链接。</p><p>尽管不是必需的，可以在第一组和第二组括号之间包含一个空格。第二组括号中的标签不区分大小写，可以包含字母，数字，空格或标点符号。</p><p>以下示例格式对于链接的第一部分效果相同：</p><ul><li><code>[hobbit-hole][1]</code></li><li><code>[hobbit-hole] [1]</code></li></ul><h4 id="链接的第二部分格式"><a href="#链接的第二部分格式" class="headerlink" title="链接的第二部分格式"></a>链接的第二部分格式</h4><p>引用类型链接的第二部分使用以下属性设置格式：</p><ol><li>放在括号中的标签，其后紧跟一个冒号和至少一个空格（例如<code>[label]:</code>）。</li><li>链接的URL，可以选择将其括在尖括号中。</li><li>链接的可选标题，可以将其括在双引号，单引号或括号中。</li></ol><p>以下示例格式对于链接的第二部分效果相同：</p><ul><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle (Hobbit lifestyles)</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &quot;Hobbit lifestyles&quot;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; &#39;Hobbit lifestyles&#39;</code></li><li><code>[1]: &lt;https://en.wikipedia.org/wiki/Hobbit#Lifestyle&gt; (Hobbit lifestyles)</code></li></ul><p>可以将链接的第二部分放在Markdown文档中的任何位置。有些人将它们放在出现的段落之后，有些人则将它们放在文档的末尾（例如尾注或脚注）。</p><h2 id="十、图片语法"><a href="#十、图片语法" class="headerlink" title="十、图片语法(![]( &quot;&quot;))"></a>十、图片语法(<code>![]( &quot;&quot;)</code>)</h2><p>要添加图像，请使用感叹号 (<code>!</code>), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</p><p>插入图片Markdown语法代码：<code>![图片alt](图片链接 &quot;图片title&quot;)</code>。</p><h2 id="十一、转义字符语法（-）"><a href="#十一、转义字符语法（-）" class="headerlink" title="十一、转义字符语法（\）"></a>十一、转义字符语法（<code>\</code>）</h2><p>要显示原本用于格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><h2 id="十二、内嵌HTML标签"><a href="#十二、内嵌HTML标签" class="headerlink" title="十二、内嵌HTML标签"></a>十二、内嵌HTML标签</h2><p>没啥特殊作用，可以不用（知道markdown语法和HTML可以级联就好）</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>Markdown</li><li>AI</li><li>Algorithm</li><li>Blog</li><li>git</li><li>Code</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>学习笔记</li><li>教程</li><li>计算机网络</li><li>算法</li><li>梦啥说啥</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于此网站</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="欢迎来到Mango的Blog！！！"><a href="#欢迎来到Mango的Blog！！！" class="headerlink" title="欢迎来到Mango的Blog！！！"></a>欢迎来到Mango的Blog！！！</h3><p>在这里，我将会分享个人在学习、工作以及爱好等方面的文章，希望能和大家交流互助~</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="😎以上所有内容仅限学习交流使用！！"><a href="#😎以上所有内容仅限学习交流使用！！" class="headerlink" title="😎以上所有内容仅限学习交流使用！！"></a>😎以上所有内容仅限学习交流使用！！</h3>]]></content>
      
    </entry>
    
    
  
</search>
